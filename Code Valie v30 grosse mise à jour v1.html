<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crypto Survivor: To The Moon</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    
    <!-- Ajout de la biblioth√®que Tone.js pour l'audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>

    <style>
        :root {
            /* Palette de couleurs th√©matique MVX */
            --bg-color: #0a192f;
            --primary-color: #00f5d4;
            --secondary-color: #112240;
            --font-color: #f0f0f0;
            --xp-color: #f1c40f; 
            --double-xp-color: #9d4edd;
            --health-color: #2ecc71;
            --money-color: #f1c40f;
            --boss-color: #ff414d;
            --disabled-color: #555;

            /* Couleurs des cryptos */
            --avax-color: #e84142;
            --mvx-color: #00f5d4;
            --eth-color: #627eea;
            --sol-color: #9945FF;
            --aave-color: #B6509E;
            --grt-color: #6f4cff;
            --doge-color: #c3a634;
            --cro-color: #0c1b42;
            --zil-color: #49c6ad;
            --bnb-color: #f0b90b;
            --htm-color: #ff8a5c;
            --btc-color: #f7931a;
            
            /* Couleurs des niveaux d'am√©lioration */
            --level-1-color: #ffffff; /* Blanc */
            --level-2-color: #2ecc71; /* Vert */
            --level-3-color: #3498db; /* Bleu */
            --level-4-color: #9b59b6; /* Violet */
            --level-5-color: #e67e22; /* Orange */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--font-color);
        }

        #game-canvas {
            display: block;
            background-color: var(--bg-color);
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .hidden {
            display: none !important;
        }
        
        /* Classe pour le X de la monnaie */
        .mvx-logo-inline {
            display: inline-block;
            transform: rotate(90deg);
            margin: 0 -2px 0 2px;
            color: var(--primary-color);
        }

        /* --- √âcrans (Menu, Game Over, Boutique) --- */
        .screen {
            z-index: 10;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 25, 47, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .screen.active {
            opacity: 1;
            pointer-events: auto;
        }

        .screen-content {
            background-color: var(--secondary-color);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(0, 245, 212, 0.3);
            max-width: 90vw;
            width: 650px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .screen h1 { font-size: 2.5rem; color: var(--primary-color); margin-bottom: 10px; font-family: 'Roboto Mono', monospace; }
        .screen h2 { font-size: 1.8rem; color: var(--primary-color); margin-bottom: 15px; }
        .screen p { margin-bottom: 20px; font-size: 1rem; }
        
        /* --- Menu Principal --- */
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 20px;
        }

        /* --- S√©lection du Personnage --- */
        .character-choices { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-bottom: 20px; }
        .char-button {
            background-color: transparent;
            border: 2px solid var(--font-color);
            color: var(--font-color);
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 95px;
        }
        .char-button.locked { border-color: #555; color: #555; cursor: not-allowed; }
        .char-button:not(.locked):hover { border-color: var(--primary-color); background-color: rgba(0, 245, 212, 0.1); }
        .char-icon { font-family: 'Roboto Mono', monospace; font-size: 1.8rem; font-weight: bold; display: inline-block; }
        .mvx-logo-select {
            transform: rotate(90deg);
        }
        .char-button strong { font-size: 0.8rem; }
        .char-button small { font-size: 0.6rem; opacity: 0.8; }

        /* --- S√©lection de la Carte --- */
        .map-choices {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 20px 0;
        }
        .map-option {
            background-color: var(--bg-color);
            border: 2px solid var(--font-color);
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }
        .map-option.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px var(--primary-color);
        }
        .map-preview {
            width: 150px;
            height: 150px;
            background-color: var(--secondary-color);
            border: 1px solid var(--primary-color);
            margin: 0 auto 10px auto;
            position: relative;
        }
        .map-preview-line-v {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            background-color: var(--primary-color);
            transform: translateX(-50%);
        }
        .map-preview-line-h {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background-color: var(--primary-color);
            transform: translateY(-50%);
        }
        .map-option strong {
            font-size: 1.2rem;
            display: block;
        }
        .map-option span {
            color: #ccc;
        }


        /* --- Options de Level Up --- */
        #level-up-options { display: flex; flex-direction: column; gap: 15px; }
        .level-up-option {
            background-color: var(--bg-color);
            border: 2px solid var(--font-color);
            color: var(--font-color);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }
        .level-up-option:hover { border-color: var(--xp-color); background-color: rgba(241, 196, 15, 0.1); }
        .level-up-option.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }
        .level-up-option.disabled { opacity: 0.5; cursor: not-allowed; background-color: var(--secondary-color); }
        .level-up-option strong { font-size: 1.1rem; }
        .level-up-option p { font-size: 0.9rem; margin: 5px 0 0 0; opacity: 0.9; }
        
        .level-up-option[data-level="1"] strong { color: var(--level-1-color); }
        .level-up-option[data-level="2"] strong { color: var(--level-2-color); }
        .level-up-option[data-level="3"] strong { color: var(--level-3-color); }
        .level-up-option[data-level="4"] strong { color: var(--level-4-color); }
        .level-up-option[data-level="5"] strong { color: var(--level-5-color); }

        /* --- √âcran Boutique --- */
        #shop-wallet-display {
            font-family: 'Roboto Mono', monospace;
            font-size: 1.5rem;
            color: var(--money-color);
            margin-bottom: 20px;
        }
        #shop-items-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            text-align: left;
        }
        .shop-item {
            background-color: var(--bg-color);
            border: 2px solid var(--font-color);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .shop-item-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .shop-item-info strong { font-size: 1.1rem; }
        .shop-item-info p { font-size: 0.9rem; margin: 0; opacity: 0.8; }
        .shop-item-action button {
            background-color: var(--money-color);
            color: var(--bg-color);
            padding: 10px 20px;
            font-size: 1rem;
        }
        .shop-item-action button:disabled {
            background-color: var(--disabled-color);
            cursor: not-allowed;
        }
        .shop-item-action span {
             font-family: 'Roboto Mono', monospace;
        }

        /* --- Boutons d'action --- */
        .action-button {
            background-color: var(--primary-color);
            border: none;
            color: var(--bg-color);
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: bold;
            transition: transform 0.2s ease, background-color 0.2s;
            margin-top: 10px;
        }
        .action-button:hover:not(:disabled) { transform: scale(1.05); }
        .action-button:disabled {
             background-color: var(--disabled-color);
             cursor: not-allowed;
        }
        
        /* --- Formulaires Multijoueur --- */
        .form-group {
            margin-bottom: 15px;
            text-align: left;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid var(--primary-color);
            background-color: var(--bg-color);
            color: var(--font-color);
            font-family: 'Poppins', sans-serif;
        }
        
        /* --- Salon d'attente --- */
        #waiting-room-info {
            font-family: 'Roboto Mono', monospace;
            margin-bottom: 20px;
        }
        #player-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            max-height: 150px;
            overflow-y: auto;
        }
        #player-list li {
            background-color: var(--bg-color);
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 5px;
        }

        /* --- HUD (Interface en jeu) --- */
        #game-hud { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            right: 10px; 
            color: white; 
            z-index: 5; 
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
        }
        #hud-left-column {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #hud-right-column {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }
        #stats-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px; 
            background-color: rgba(17, 34, 64, 0.8);
            border-radius: 8px; 
            border: 1px solid var(--primary-color);
            font-family: 'Roboto Mono', monospace; 
        }
        #stats-left { display: flex; gap: 20px; }
        
        #top-health-bar {
            width: 100%;
            height: 12px;
            background-color: rgba(17, 34, 64, 0.8);
            border-radius: 6px;
            border: 1px solid var(--primary-color);
            position: relative;
            overflow: hidden;
        }
        #top-health-bar-fill {
            width: 100%;
            height: 100%;
            background-color: var(--health-color);
            border-radius: 5px;
            transition: width 0.3s ease;
        }
        #top-health-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.7rem;
            font-weight: bold;
            color: var(--bg-color);
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
            width: 100%;
            text-align: center;
        }
        
        #xp-bar-container { 
            width: 100%; 
            height: 12px;
            background-color: rgba(17, 34, 64, 0.8);
            border-radius: 6px; 
            border: 1px solid var(--primary-color);
            position: relative;
            overflow: hidden;
        }
        #xp-bar { 
            width: 0%; 
            height: 100%; 
            background-color: var(--xp-color); 
            border-radius: 5px; 
            transition: width 0.3s ease; 
        }
        #xp-bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.7rem;
            font-weight: bold;
            color: var(--bg-color);
            text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
            width: 100%;
            text-align: center;
        }

        #minimap-canvas {
            width: 80px;
            height: 80px;
            background-color: rgba(17, 34, 64, 0.8);
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            flex-shrink: 0;
            pointer-events: auto;
        }
        #bonus-timer {
            position: absolute;
            top: 95px;
            right: 10px;
            background-color: rgba(17, 34, 64, 0.8);
            border: 1px solid var(--primary-color);
            border-radius: 8px;
            padding: 5px 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            color: white;
            z-index: 6;
        }

        /* --- Contr√¥les (Joystick & Boutons) --- */
        #joystick-container { position: absolute; width: 120px; height: 120px; background-color: rgba(255, 255, 255, 0.1); border-radius: 50%; z-index: 6; display: none; pointer-events: none; }
        #joystick-handle { position: absolute; top: 50%; left: 50%; width: 60px; height: 60px; background-color: rgba(255, 255, 255, 0.3); border-radius: 50%; transform: translate(-50%, -50%); }

        #special-ability-button { 
            position: absolute; 
            bottom: 80px; 
            right: 20px; 
            width: 60px; 
            height: 60px; 
            border-radius: 50%; 
            background-color: rgba(0, 245, 212, 0.5);
            border: 3px solid var(--primary-color); 
            color: white; 
            font-size: 1.8rem; 
            z-index: 6; 
            cursor: pointer; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            transition: all 0.2s ease; 
        }
        #special-ability-button.on-cooldown { background-color: rgba(128, 128, 128, 0.5); border-color: #888; cursor: not-allowed; }
        #special-ability-button:not(.on-cooldown):hover { transform: scale(1.1); }
        
        /* --- Affichages UI en jeu --- */
        #passive-upgrades-display { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; background-color: rgba(0,0,0,0.4); padding: 5px 10px; border-radius: 10px; z-index: 5; pointer-events: none; max-width: 80%; }
        .passive-upgrade-icon { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; font-family: 'Roboto Mono', monospace; }
        
        #weapon-display-ui {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 5px;
            background-color: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 8px;
            z-index: 5;
            max-width: 120px;
        }
        .weapon-icon {
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
        }
        .weapon-icon span:first-child {
            font-size: 1rem;
            width: 20px;
            text-align: center;
        }

        /* --- Boutons UI en jeu (Pause, Mute) --- */
        .game-ui-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--primary-color);
            background-color: rgba(17, 34, 64, 0.8);
            color: var(--primary-color);
            font-size: 1.2rem;
            cursor: pointer;
            z-index: 11;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        .game-ui-button:hover {
            background-color: var(--primary-color);
            color: var(--bg-color);
        }
        #mute-button {
            position: absolute;
            bottom: 20px;
            left: 20px;
        }
        #pause-button {
            pointer-events: auto; /* Rendre cliquable */
            font-family: 'Roboto Mono', monospace;
            font-weight: bold;
        }

        /* --- Panneaux Lat√©raux (Arm√©e & Am√©liorations) --- */
        .side-panel {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 200px;
            background-color: rgba(17, 34, 64, 0.9);
            border: 1px solid var(--primary-color);
            padding: 10px;
            z-index: 6;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: 0.3s ease-in-out;
        }
        .side-panel-toggle {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 25px;
            height: 60px;
            background-color: var(--secondary-color);
            border: 1px solid var(--primary-color);
            cursor: pointer;
            color: var(--primary-color);
            font-size: 1.2rem;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease;
        }
        .side-panel-toggle:hover {
            background-color: var(--primary-color);
            color: var(--bg-color);
        }
        .side-panel.collapsed .side-panel-toggle > span {
            transform: rotate(180deg);
        }
        .side-panel h3 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 5px;
            font-size: 1rem;
        }

        #army-purchase-panel {
            right: 10px;
            border-right: none;
            border-radius: 10px 0 0 10px;
            padding-left: 25px;
        }
        #army-purchase-panel.collapsed {
            right: -185px;
        }
        #army-panel-toggle {
            left: 0;
            border-right: none;
            border-radius: 8px 0 0 8px;
        }

        #upgrade-panel {
            left: 10px;
            border-left: none;
            border-radius: 0 10px 10px 0;
            padding-right: 25px;
        }
        #upgrade-panel.collapsed {
            left: -185px;
        }
        #upgrade-panel-toggle {
            right: 0;
            border-left: none;
            border-radius: 0 8px 8px 0;
        }
        #upgrade-panel-toggle > span {
            transform: rotate(180deg);
        }
        #upgrade-panel.collapsed #upgrade-panel-toggle > span {
            transform: rotate(0deg);
        }
        
        #skill-points-display {
            font-family: 'Roboto Mono', monospace;
            text-align: center;
            font-size: 1.2rem;
            color: var(--xp-color);
            margin-bottom: 10px;
        }
        .upgrade-category {
            font-size: 0.8rem;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
            opacity: 0.7;
        }
        .upgrade-button {
            background-color: var(--secondary-color);
            border: 1px solid var(--font-color);
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            font-size: 0.9rem;
            color: var(--font-color);
        }
        .upgrade-button:hover:not(:disabled) {
            border-color: var(--xp-color);
            background-color: rgba(241, 196, 15, 0.1);
        }
        .upgrade-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .upgrade-cost {
            font-family: 'Roboto Mono', monospace;
            font-weight: bold;
            color: var(--xp-color);
        }


        .army-unit-button {
            background-color: var(--secondary-color);
            border: 1px solid var(--font-color);
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .army-unit-button:hover {
            border-color: var(--primary-color);
            background-color: rgba(0, 245, 212, 0.1);
        }
        .army-unit-button .unit-shape {
            font-size: 1.5rem;
            color: var(--primary-color);
            width: 30px;
            text-align: center;
        }
        .army-unit-button .unit-info {
            display: flex;
            flex-direction: column;
        }
        .army-unit-button .unit-name {
            font-weight: bold;
            font-size: 0.9rem;
        }
        .army-unit-button .unit-cost {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
            color: var(--money-color);
        }

        /* --- Styles pour la fusion --- */
        #fusion-title {
            margin-top: 15px;
            border-top: 1px solid var(--primary-color);
            padding-top: 10px;
        }
        .fusion-button {
            background-color: var(--secondary-color);
            border-width: 1px;
            border-style: solid;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }
         .fusion-button:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.1);
         }
         .fusion-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
         }
        .fusion-button .unit-shape {
            font-size: 1.5rem;
            width: 30px;
            text-align: center;
        }
         .fusion-button .unit-info {
            display: flex;
            flex-direction: column;
         }
        .fusion-button .unit-name {
            font-weight: bold;
            font-size: 0.9rem;
        }
        .fusion-button .unit-cost {
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
        }

        /* --- Barre de chargement du Pentagramme --- */
        #pentagram-charge-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 20px;
            background-color: rgba(17, 34, 64, 0.8);
            border: 2px solid var(--boss-color);
            border-radius: 10px;
            z-index: 7;
            pointer-events: none;
            overflow: hidden;
        }
        #pentagram-charge-bar {
            width: 0%;
            height: 100%;
            background-color: var(--boss-color);
            border-radius: 8px;
            transition: width 0.1s linear;
        }
        #pentagram-charge-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Roboto Mono', monospace;
            font-size: 0.8rem;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
        }


        /* --- OPTIMISATIONS POUR MOBILE --- */
        @media (max-width: 768px) {
            #hud-left-column {
                gap: 5px;
            }
            #stats-container {
                padding: 4px 8px;
                font-size: 0.8rem;
            }
            #stats-left {
                gap: 10px;
            }
            #top-health-bar, #xp-bar-container {
                height: 8px;
            }
             #top-health-bar-text, #xp-bar-text {
                font-size: 0.6rem;
            }
            #hud-right-column {
                gap: 5px;
            }
            #minimap-canvas {
                width: 60px;
                height: 60px;
            }
            #pause-button {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
            .side-panel {
                width: 110px;
                padding: 5px;
                gap: 5px;
            }
            #army-purchase-panel {
                padding-left: 25px;
            }
            #army-purchase-panel.collapsed {
                right: -90px;
            }
            #upgrade-panel {
                padding-right: 25px;
            }
            #upgrade-panel.collapsed {
                left: -90px;
            }
            .side-panel h3 {
                display: none;
            }
            .army-unit-button, .fusion-button {
                padding: 4px;
                gap: 5px;
                flex-direction: row;
            }
            .army-unit-button .unit-name, .fusion-button .unit-name {
                display: none;
            }
            .army-unit-button .unit-info, .fusion-button .unit-info {
                align-items: flex-start;
            }
            .army-unit-button .unit-shape, .fusion-button .unit-shape {
                font-size: 1rem;
                width: 20px;
            }
            .army-unit-button .unit-cost, .fusion-button .unit-cost {
                font-size: 0.7rem;
            }
            #special-ability-button {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
                bottom: 70px;
                right: 15px;
            }
             #mute-button {
                bottom: 15px;
                left: 15px;
            }
        }

        /* --- √âcran de Connexion --- */
        #login-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            text-align: left;
        }

        .input-group label {
            font-weight: bold;
            font-size: 0.9rem;
        }

        .input-group input {
            padding: 10px;
            border-radius: 5px;
            border: 2px solid var(--font-color);
            background-color: var(--bg-color);
            color: var(--font-color);
            font-family: 'Poppins', sans-serif;
        }

        .password-strength {
            height: 5px;
            width: 0%;
            background-color: grey;
            border-radius: 5px;
            transition: width 0.3s, background-color 0.3s;
        }

        #password-strength-text {
            font-size: 0.8rem;
            height: 1em;
        }

        #login-error {
            color: #e74c3c;
            min-height: 1.2em;
            font-weight: bold;
        }

        .form-toggle {
            margin-top: 15px;
        }

        .form-toggle .toggle-link {
            color: var(--primary-color);
            cursor: pointer;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <!-- √âcran de Connexion -->
    <div id="login-screen" class="screen active">
        <div class="screen-content">
            <h1 id="login-title">Connexion</h1>
            <form id="login-form">
                <div class="input-group">
                    <label for="username">Pseudo</label>
                    <input type="text" id="username" name="username" required autocomplete="username">
                </div>
                <div class="input-group">
                    <label for="password">Mot de passe</label>
                    <input type="password" id="password" name="password" required autocomplete="current-password">
                </div>
                <div class="input-group hidden" id="confirm-password-group">
                    <label for="confirm-password">Confirmer le mot de passe</label>
                    <input type="password" id="confirm-password" name="confirm-password" autocomplete="new-password">
                    <div class="password-strength" id="password-strength-bar"></div>
                    <span id="password-strength-text"></span>
                </div>

                <div id="login-error"></div>

                <button type="submit" class="action-button" id="submit-button">Se connecter</button>
            </form>
            <div class="form-toggle">
                <span id="toggle-text">Pas encore de compte ? <span class="toggle-link" id="toggle-to-register">Inscrivez-vous</span></span>
            </div>
        </div>
    </div>
    <!-- Menu Principal -->
    <div id="main-menu-screen" class="screen">
        <div class="screen-content">
            <h1>Crypto Survivor</h1>
            <div id="player-greeting" style="margin-top: 10px; font-size: 1.2rem; color: var(--primary-color);"></div>
            <div class="menu-buttons">
                <button id="start-game-button" class="action-button">Survivor Mode</button>
                <button id="multiplayer-button" class="action-button">Multijoueur</button>
                <button id="shop-button" class="action-button">Boutique</button>
                <button id="options-button" class="action-button" disabled>Options</button>
            </div>
        </div>
    </div>

    <!-- √âcran de Boutique -->
    <div id="shop-screen" class="screen">
        <div class="screen-content">
            <h1>Boutique</h1>
            <p>Am√©liorations Permanentes</p>
            <div id="shop-wallet-display">0</div>
            <div id="shop-items-container">
                <!-- Les objets de la boutique sont inject√©s ici par JavaScript -->
            </div>
            <button id="back-to-menu-button" class="action-button">Retour</button>
        </div>
    </div>

    <!-- √âcran de s√©lection du personnage -->
    <div id="character-selection-screen" class="screen">
        <div class="screen-content">
            <h1>Crypto Survivor</h1>
            <p>Choisissez votre Crypto</p>
            <div class="character-choices" id="character-choices-container">
                <!-- Les personnages sont inject√©s ici par JavaScript -->
            </div>
            <button id="back-to-menu-from-char-select-button" class="action-button">Retour</button>
        </div>
    </div>

    <!-- √âcran de S√©lection de Mode Multijoueur -->
    <div id="multiplayer-mode-screen" class="screen">
        <div class="screen-content">
            <h1>Multijoueur</h1>
            
            <div class="form-group">
                <label for="server-url-input">Adresse du Serveur</label>
                <input type="text" id="server-url-input" value="https://crypto-survivor.onrender.com">
            </div>
            <button id="connect-to-server-btn" class="action-button">Connexion</button>
            <div id="connection-status" style="min-height: 1.2em; margin-top: 10px; font-weight: bold;"></div>

            <div class="menu-buttons" style="margin-top: 20px; border-top: 1px solid var(--primary-color); padding-top: 20px;">
                <button id="create-private-game-btn" class="action-button" disabled>Cr√©er une partie priv√©e</button>
                <button id="join-private-game-btn" class="action-button" disabled>Rejoindre une partie priv√©e</button>
                <button id="army-attack-button" class="action-button">Jouer contre l'IA (Army Attack)</button>
                <button id="back-to-main-menu-from-multiplayer-mode" class="action-button back-button">Retour</button>
            </div>
        </div>
    </div>

    <!-- √âcran de cr√©ation de partie avec mot de passe -->
    <div id="create-game-password-screen" class="screen">
        <div class="screen-content">
            <h1>Cr√©er une partie priv√©e</h1>
            <p>Choisissez un mot de passe pour votre partie.</p>
            <div class="input-group">
                <label for="create-game-password-input">Mot de passe</label>
                <input type="text" id="create-game-password-input" placeholder="Mot de passe (4-8 caract√®res)">
            </div>
            <div class="menu-buttons" style="margin-top: 20px;">
                <button id="create-game-next-btn" class="action-button" disabled>Suivant</button>
                <button id="back-to-multiplayer-mode-from-create" class="action-button back-button">Retour</button>
            </div>
        </div>
    </div>

    <!-- √âcran pour rejoindre une partie avec un code -->
    <div id="join-game-code-screen" class="screen">
        <div class="screen-content">
            <h1>Rejoindre une partie priv√©e</h1>
            <p>Entrez le code de la partie que vous souhaitez rejoindre.</p>
            <div class="input-group">
                <label for="join-game-code-input">Code de la partie</label>
                <input type="text" id="join-game-code-input" placeholder="Code √† 6 caract√®res">
            </div>
            <div class="menu-buttons" style="margin-top: 20px;">
                <button id="join-game-confirm-btn" class="action-button" disabled>Rejoindre</button>
                <button id="back-to-multiplayer-mode-from-join" class="action-button back-button">Retour</button>
            </div>
        </div>
    </div>

    <!-- √âcran de S√©lection de Carte -->
    <div id="map-selection-screen" class="screen">
        <div class="screen-content">
            <h2>Choisissez une carte</h2>
            <div class="map-choices">
                <div class="map-option" data-map-id="quadrant_4p">
                    <div class="map-preview">
                        <div class="map-preview-line-v"></div>
                        <div class="map-preview-line-h"></div>
                    </div>
                    <strong>Ar√®ne 4 Joueurs</strong>
                    <span>4 Joueurs</span>
                </div>
                 <div class="map-option" data-map-id="vertical_2p">
                    <div class="map-preview">
                        <div class="map-preview-line-h"></div>
                    </div>
                    <strong>Duel Vertical</strong>
                    <span>2 Joueurs</span>
                </div>
            </div>
            <div class="menu-buttons">
                 <button id="next-from-map-select-button" class="action-button" disabled>Suivant</button>
                 <button id="back-to-menu-from-map-select-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
            </div>
        </div>
    </div>
    
    <!-- √âcran du Lobby Multijoueur -->
    <div id="multiplayer-lobby-screen" class="screen">
        <div class="screen-content">
            <h2>Multijoueur</h2>
            <p>Connect√© en tant que : <strong id="lobby-player-name"></strong></p>
            <div class="form-group">
                <label for="game-id-input">ID de la partie</label>
                <input type="text" id="game-id-input" placeholder="Entrez un ID pour rejoindre...">
            </div>
            <button id="join-game-button" class="action-button" disabled>Rejoindre</button>
            <button id="create-game-button" class="action-button">Cr√©er une partie</button>
            <button id="back-to-menu-from-lobby-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
        </div>
    </div>

    <!-- √âcran du Salon d'attente -->
    <div id="waiting-room-screen" class="screen">
        <div class="screen-content">
            <h2>Salon d'attente</h2>
            <p id="waiting-room-info">ID de la partie : <span id="game-id-display"></span></p>
            <h3>Joueurs (<span id="player-count">1</span>/<span id="max-players">4</span>)</h3>
            <ul id="player-list">
                <!-- La liste des joueurs sera remplie par JavaScript -->
            </ul>
            <div class="menu-buttons">
                <button id="start-vs-ai-button" class="action-button">Jouer contre l'IA</button>
                <button id="start-multiplayer-game-button" class="action-button" disabled>Lancer la partie (2+ Joueurs)</button>
                <button id="back-to-lobby-from-waiting-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
            </div>
        </div>
    </div>


    <!-- √âcran de Pause -->
    <div id="pause-screen" class="screen">
        <div class="screen-content">
            <h2>PAUSE</h2>
            <div class="menu-buttons">
                <button id="resume-button" class="action-button">Continuer</button>
                <button id="restart-from-pause-button" class="action-button">Recommencer</button>
                <button id="main-menu-from-pause-button" class="action-button">Menu Principal</button>
            </div>
        </div>
    </div>

    <!-- √âcran de Confirmation pour Quitter -->
    <div id="confirm-quit-screen" class="screen">
        <div class="screen-content">
            <h2>Quitter la partie ?</h2>
            <p>Votre progression dans cette partie sera perdue.</p>
            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="confirm-quit-yes-button" class="action-button">Oui</button>
                <button id="confirm-quit-no-button" class="action-button" style="background-color: var(--disabled-color);">Non</button>
            </div>
        </div>
    </div>

    <!-- Interface du jeu (HUD) -->
    <div id="game-hud" class="hidden">
        <div id="hud-left-column">
            <div id="stats-container">
                <div id="stats-left">
                    <div>LVL: <span id="player-level">1</span></div>
                    <div>$<span class="mvx-logo-inline">X</span> <span id="player-wallet">0</span></div>
                </div>
                <div id="game-timer">00:00</div>
            </div>
            <div id="top-health-bar">
                <div id="top-health-bar-fill"></div>
                <span id="top-health-bar-text">100 / 100</span>
            </div>
            <div id="xp-bar-container">
                <div id="xp-bar"></div>
                <span id="xp-bar-text">0 / 10</span>
            </div>
        </div>
        <div id="hud-right-column">
            <canvas id="minimap-canvas" width="80" height="80"></canvas>
            <button id="pause-button" class="game-ui-button">||</button>
        </div>
    </div>
    <div id="bonus-timer" class="hidden"></div>

    <!-- Panneau d'Am√©liorations (Gauche) -->
    <div id="upgrade-panel" class="side-panel hidden">
        <button id="upgrade-panel-toggle" class="side-panel-toggle"><span>‚óÄ</span></button>
        <div id="skill-points-display">Points: 0</div>
        <div id="multiplayer-upgrades-container">
            <!-- Les am√©liorations seront inject√©es ici -->
        </div>
    </div>

    <!-- Panneau d'Achat d'Arm√©e (Droite) -->
    <div id="army-purchase-panel" class="side-panel hidden">
        <button id="army-panel-toggle" class="side-panel-toggle"><span>‚ñ∂</span></button>
        <h3>Construire Arm√©e</h3>
        <div class="army-unit-button" data-unit="triangle">
            <span class="unit-shape">‚ñ≤</span>
            <div class="unit-info">
                <span class="unit-name">Mitrailleur</span>
                <span class="unit-cost">50 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <div class="army-unit-button" data-unit="square">
            <span class="unit-shape">‚ñ†</span>
            <div class="unit-info">
                <span class="unit-name">Artilleur</span>
                <span class="unit-cost">100 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <div class="army-unit-button" data-unit="rectangle">
            <span class="unit-shape">‚ñ¨</span>
            <div class="unit-info">
                <span class="unit-name">Lance-Missiles</span>
                <span class="unit-cost">150 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <h3 id="fusion-title" class="hidden">Fusionner</h3>
        <div id="fusion-options-container">
              <!-- Les options de fusion seront inject√©es ici -->
        </div>
    </div>


    <!-- √âcran de mont√©e de niveau -->
    <div id="level-up-screen" class="screen">
        <div class="screen-content">
            <h2 id="level-up-title">LEVEL UP!</h2>
            <p id="level-up-subtitle">Choisissez une seule am√©lioration :</p>
            <div id="level-up-options"></div>
            <button id="confirm-upgrade-button" class="action-button hidden">Confirmer</button>
        </div>
    </div>

    <!-- √âcran de fin de partie -->
    <div id="game-over-screen" class="screen">
        <div class="screen-content">
            <h2 id="game-over-title">LIQUIDATED!</h2>
            <div id="survivor-stats">
                <p>Vous avez surv√©cu <span id="final-time">00:00</span>.</p>
                <p>Niveau final : <span id="final-level">1</span></p>
                <p>Gains : <span id="final-gain">0</span> $<span class="mvx-logo-inline">X</span></p>
            </div>
            <div id="game-over-buttons" class="menu-buttons">
                <!-- Bouton pour le mode Survivor -->
                <button id="restart-button" class="action-button">Menu Principal</button>
                <!-- Nouveaux boutons pour le mode Army Attack -->
                <button id="game-over-lobby-button" class="action-button hidden">Lobby</button>
                <button id="game-over-spectate-button" class="action-button hidden">Mode Spectateur</button>
                <button id="game-over-quit-button" class="action-button hidden">Menu Principal</button>
            </div>
        </div>
    </div>
    
    <!-- Affichages UI en jeu -->
    <div id="passive-upgrades-display" class="hidden"></div>
    <div id="weapon-display-ui" class="hidden"></div>

    <!-- √âl√©ments du jeu -->
    <canvas id="game-canvas"></canvas>
    <div id="joystick-container"><div id="joystick-handle"></div></div>
    <button id="special-ability-button" class="hidden">üöÄ</button>
    <button id="mute-button" class="game-ui-button">üéµ</button>
    
    <!-- Barre de chargement du Pentagramme -->
    <div id="pentagram-charge-container" class="hidden">
        <div id="pentagram-charge-bar"></div>
        <span id="pentagram-charge-text">Invocation...</span>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- GESTIONNAIRE AUDIO ---
            const audioManager = {
                isInitialized: false,
                isMuted: false,
                currentMusicType: null,
                synths: {},
                music: {
                    menu: null,
                    game: null,
                    miniBoss: null,
                    mainBoss: null,
                    gameOver: null
                },

                async initialize() {
                    if (this.isInitialized) return;
                    await Tone.start();
                    console.log("Audio context started.");

                    // --- EFFETS SONORES ---
                    this.synths.shoot = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 },
                        volume: -15
                    }).toDestination();
                    this.synths.playerHit = new Tone.Synth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination();
                    this.synths.levelUp = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'fmsine' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.5 } }).toDestination();
                    this.synths.enemyDefeat = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' }, volume: -10 }).toDestination();
                    this.synths.collect = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 }, volume: -10 }).toDestination();
                    this.synths.healthPickup = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.1, release: 0.5 }, volume: -8 }).toDestination();
                    this.synths.explosion = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0 }, volume: -5 }).toDestination();
                    this.synths.purchase = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2 }, volume: -5 }).toDestination();


                    // --- MUSIQUE DE MENU ---
                    const menuSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "fatsawtooth", count: 3, spread: 30 }, envelope: { attack: 0.8, decay: 0.5, sustain: 0.8, release: 2 }, volume: -25 }).toDestination();
                    const menuMelodySynth = new Tone.FMSynth({
                        harmonicity: 3,
                        modulationIndex: 10,
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.2, decay: 0.3, sustain: 0.1, release: 1 },
                        volume: -15
                    }).toDestination();

                    const menuChords = [
                        { time: '0:0', notes: ['C3', 'D#3', 'G3'], duration: '1m' },
                        { time: '1:0', notes: ['G#2', 'C3', 'D#3'], duration: '1m' },
                        { time: '2:0', notes: ['D#3', 'G3', 'A#3'], duration: '1m' },
                        { time: '3:0', notes: ['A#2', 'D3', 'F3'], duration: '1m' },
                    ];
                    const menuChordPart = new Tone.Part((time, value) => { menuSynth.triggerAttackRelease(value.notes, value.duration, time); }, menuChords).start(0);
                    menuChordPart.loop = true;
                    menuChordPart.loopEnd = '4m';

                    const menuMelody = new Tone.Sequence((time, note) => {
                        if (note) menuMelodySynth.triggerAttackRelease(note, "8n", time);
                    }, [
                        'G4', 'A#4', 'C5', null, 'G4', null, 'D#4', null,
                        'G4', 'A#4', 'C5', null, 'G4', null, 'D#4', null,
                        'F4', 'G4', 'G#4', null, 'F4', null, 'D4', null,
                        'F4', 'G4', 'G#4', null, 'F4', null, 'D#4', null
                    ], "8n").start(0);
                    menuMelody.loop = true;
                    menuMelody.loopEnd = '4m';

                    // --- √âl√©ments rythmiques pour la phase 2 ---
                    const kick = new Tone.MembraneSynth({ volume: -8 }).toDestination();
                    const snare = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0 }, volume: -12 }).toDestination();
                    const hihat = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 }, volume: -20 }).toDestination();
                    const epicBass = new Tone.MonoSynth({ oscillator: { type: 'fmsquare' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 }, volume: -14 }).toDestination();

                    // Boucles rythmiques qui d√©marrent apr√®s la premi√®re passe
                    const kickLoop = new Tone.Loop(time => { kick.triggerAttackRelease('C1', '8n', time); }, '4n').start('4m');
                    const snareLoop = new Tone.Loop(time => { snare.triggerAttackRelease('8n', time); }, '2n').start('4m+4n');
                    const hihatLoop = new Tone.Loop(time => { hihat.triggerAttackRelease('16n', time); }, '8n').start('4m');

                    const epicBassPart = new Tone.Sequence((time, note) => {
                        epicBass.triggerAttackRelease(note, '4n', time);
                    }, ['C2', 'C2', 'C2', 'C2', 'G#1', 'G#1', 'G#1', 'G#1', 'D#2', 'D#2', 'D#2', 'D#2', 'A#1', 'A#1', 'A#1', 'A#1'], '4n').start('4m');
                    
                    epicBassPart.loop = true;
                    epicBassPart.loopEnd = '4m';


                    // Build-up rythmique avant la phase 2
                    const buildupPart = new Tone.Part((time, value) => {
                        hihat.triggerAttackRelease(value.duration, time);
                    }, [
                        { time: "3:2:0", duration: "16n" },
                        { time: "3:2:2", duration: "16n" },
                        { time: "3:3:0", duration: "8n" },
                        { time: "3:3:2", duration: "8n" },
                    ]).start(0);
                    buildupPart.loop = false; // Ne se joue qu'une fois

                    this.music.menu = [menuChordPart, menuMelody, kickLoop, snareLoop, hihatLoop, epicBassPart, buildupPart];


                    // --- MUSIQUE DE GAME OVER ---
                    const gameOverMelodySynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'fatsawtooth' }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 1 }, volume: -12 }).toDestination();
                    this.music.gameOver = new Tone.Sequence((time, note) => { gameOverMelodySynth.triggerAttackRelease(note, '4n', time); }, ['G3', 'D#3', 'C3', 'G2'], '4n');
                    this.music.gameOver.loop = false;

                    // --- MUSIQUES DE JEU ET BOSS ---
                    const createMusicLoop = (bpm, bassNotes, arpNotes, leadNotes = null) => {
                        const parts = [];
                        const kick = new Tone.MembraneSynth({ volume: -6 }).toDestination();
                        const snare = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.2, sustain: 0 }, volume: -12 }).toDestination();
                        const hihat = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 }, volume: -20 }).toDestination();
                        const bass = new Tone.MonoSynth({ oscillator: { type: 'fmsquare' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.4 }, volume: -10 }).toDestination();
                        const arpSynth = new Tone.FMSynth({ harmonicity: 1.5, modulationIndex: 5, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }, volume: -20 }).toDestination();
                        
                        parts.push(new Tone.Loop(time => { kick.triggerAttackRelease('C1', '8n', time); }, '4n'));
                        parts.push(new Tone.Loop(time => { hihat.triggerAttackRelease('16n', time); }, '8n'));
                        if (leadNotes) { // Ajout de la caisse claire pour les boss
                             parts.push(new Tone.Loop(time => { snare.triggerAttackRelease('16n', time); }, '2n').start('4n'));
                        }
                        parts.push(new Tone.Sequence((time, note) => { bass.triggerAttackRelease(note, '2n', time); }, bassNotes, '1m'));
                        parts.push(new Tone.Sequence((time, note) => { arpSynth.triggerAttackRelease(note, '16n', time); }, arpNotes, '16n'));
                        
                        if(leadNotes) {
                                 const leadSynth = new Tone.DuoSynth({vibratoAmount: 0.1, harmonicity: 1, voice0: {oscillator: {type: 'sawtooth'}}, voice1: {oscillator: {type: 'sine'}}, volume: -15}).toDestination();
                                 parts.push(new Tone.Sequence((time, note) => { leadSynth.triggerAttackRelease(note, '8n', time); }, leadNotes, '8n'));
                        }
                        return parts;
                    };
                    
                    this.music.game = createMusicLoop(130, ['C2', 'G#1', 'D#2', 'A#1'], ['C3', 'D#3', 'G3', 'D#3']);
                    this.music.miniBoss = createMusicLoop(140, ['C2', 'C2', 'G#1', 'G#1', 'D#2', 'D#2', 'A#1', 'A#1'], ['C4', 'D#4', 'G4', 'D#4'], ['C5', null, 'D#5', null]);
                    this.music.mainBoss = createMusicLoop(150, ['C2', 'C2', 'C2', 'G#1', 'D#2', 'D#2', 'D#2', 'A#1'], ['C4', 'D#4', 'G4', 'A#4'], ['C5', 'D#5', 'G5', 'A#5', 'C6', 'A#5', 'G5', 'D#5']);

                    this.isInitialized = true;
                },

                play(sound) {
                    if (!this.isInitialized || this.isMuted) return;
                    try {
                        if (this.synths[sound]) {
                            if (sound === 'levelUp') this.synths.levelUp.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '4n');
                            else if (sound === 'healthPickup') this.synths.healthPickup.triggerAttackRelease('A4', '8n');
                            else if (sound === 'explosion') this.synths.explosion.triggerAttackRelease('4n');
                            else if (sound === 'playerHit') this.synths.playerHit.triggerAttackRelease('G2', '8n');
                            else if (sound === 'enemyDefeat') this.synths.enemyDefeat.triggerAttackRelease("C1", "8n");
                            else if (sound === 'collect') this.synths.collect.triggerAttackRelease('C6', '16n');
                            else if (sound === 'shoot') this.synths.shoot.triggerAttackRelease('C5', '8n', Tone.now());
                            else if (sound === 'purchase') this.synths.purchase.triggerAttackRelease('C5', '8n');
                        }
                    } catch (e) { console.error(`Error playing sound ${sound}:`, e); }
                },

                playMusic(type) {
                    if (!this.isInitialized || this.isMuted) return;
                    this.stopAllMusic();
                    this.currentMusicType = type;
                    
                    const musicToPlay = this.music[type];
                    if (musicToPlay) {
                        if (Array.isArray(musicToPlay)) {
                            musicToPlay.forEach(part => part.start(0));
                        } else {
                            musicToPlay.start(0);
                        }
                    }
                    
                    if (Tone.Transport.state !== 'started') {
                        Tone.Transport.start();
                    }
                },

                stopAllMusic() {
                    if (!this.isInitialized) return;
                    Object.values(this.music).forEach(musicPart => {
                        if (musicPart) {
                            if (Array.isArray(musicPart)) {
                                musicPart.forEach(part => part.stop(0));
                            } else {
                                musicPart.stop(0);
                            }
                        }
                    });
                    if (Tone.Transport.state === 'started') {
                        Tone.Transport.stop();
                        Tone.Transport.cancel(0);
                        Tone.Transport.position = 0;
                    }
                },

                toggleMute() {
                    this.isMuted = !this.isMuted;
                    Tone.Destination.mute = this.isMuted;
                    document.getElementById('mute-button').textContent = this.isMuted ? 'üîá' : 'üéµ';
                    
                    if (this.isMuted) {
                        this.stopAllMusic();
                    } else {
                        // Relance la musique appropri√©e en fonction de l'√©tat du jeu
                        const activeScreen = document.querySelector('.screen.active');
                        if (activeScreen && activeScreen.id.includes('main-menu')) {
                            this.playMusic('menu');
                        } else if (gameState === 'running') {
                             if (activeMiniBoss) {
                                 this.playMusic(activeMiniBoss.isDemiBoss ? 'miniBoss' : 'mainBoss');
                            } else {
                                 this.playMusic('game');
                            }
                        }
                    }
                }
            };

            // --- CONSTANTES & CONFIGURATION ---
            const canvas = document.getElementById('game-canvas');
            const ctx = canvas.getContext('2d');
            const WORLD_WIDTH = 5000;
            const WORLD_HEIGHT = 5000;
            const ENEMY_BASE_SPAWN_RATE = 2000; // ms
            const MAGNET_SPAWN_RATE = 25000; // 25 secondes
            const HEALTH_SPAWN_RATE = 20000; // 20 secondes
            const TOWER_WAVE_INTERVAL = 8000; // intervalle entre vagues (ms)

            // --- √âTAT DU JEU ---
            let gameState = 'login';
            let currentPlayer = null;
            let gameMode = 'survivor'; // 'survivor' ou 'armyAttack'
            let players = []; // G√®re tous les joueurs (humain + bots)
            let animationFrameId = null;
            let lastTime = 0;
            let spectatedPlayer = null;
            let previousGameState = null;
            let camera = { x: 0, y: 0 };
            let zoomFactor = 1.0; // Facteur de zoom pour le mobile
            let entities = {
                enemies: [], projectiles: [], xpOrbs: [], particles: [],
                floatingTexts: [], healthPickups: [], magnets: [], bonusUpgrades: [],
                soldiers: [], pentagrams: []
            };
            let timers = { game: 0, enemySpawn: 0, healthSpawn: 0, magnetSpawn: 0 };
            let armyAttackTimers = { wave: 0, waveCount: 0 };
            let activeMiniBoss = null;
            let selectedUpgrades = [];
            let selectedMap = null;
            
            // --- Donn√©es persistantes ---
            let globalWallet = 0;
            let unlockedCharacters = ['MVX'];
            let permanentUpgrades = {
                damage: 0, // Niveau actuel
                health: 0,
                xpGain: 0,
                attackSpeed: 0,
            };

            // --- S√âLECTEURS D'√âL√âMENTS DU DOM ---
            const dom = {
                canvas: document.getElementById('game-canvas'),
                ctx: document.getElementById('game-canvas').getContext('2d'),
                screens: {
                    mainMenu: document.getElementById('main-menu-screen'),
                    shop: document.getElementById('shop-screen'),
                    characterSelection: document.getElementById('character-selection-screen'),
                    mapSelection: document.getElementById('map-selection-screen'),
                    multiplayerMode: document.getElementById('multiplayer-mode-screen'),
                    createGamePassword: document.getElementById('create-game-password-screen'),
                    joinGameCode: document.getElementById('join-game-code-screen'),
                    multiplayerLobby: document.getElementById('multiplayer-lobby-screen'),
                    waitingRoom: document.getElementById('waiting-room-screen'),
                    pause: document.getElementById('pause-screen'),
                    confirmQuit: document.getElementById('confirm-quit-screen'),
                    gameOver: document.getElementById('game-over-screen'),
                    levelUp: document.getElementById('level-up-screen'),
                },
                buttons: {
                    // Menu Principal
                    startGame: document.getElementById('start-game-button'),
                    multiplayer: document.getElementById('multiplayer-button'),
                    shop: document.getElementById('shop-button'),
                    // Menu Multijoueur
                    createPrivateGame: document.getElementById('create-private-game-button'),
                    joinPrivateGame: document.getElementById('join-private-game-button'),
                    armyAttack: document.getElementById('army-attack-button'),
                    backToMainMenuFromMultiplayerMode: document.getElementById('back-to-main-menu-from-multiplayer-mode'),
                    // √âcran Cr√©er Partie
                    createGameNext: document.getElementById('create-game-next-button'),
                    backToMultiplayerModeFromCreate: document.getElementById('back-to-multiplayer-mode-from-create'),
                    // √âcran Rejoindre Partie
                    joinGameConfirm: document.getElementById('join-game-confirm-button'),
                    backToMultiplayerModeFromJoin: document.getElementById('back-to-multiplayer-mode-from-join'),
                    // Autres retours & navigation
                    backToMenuFromShop: document.getElementById('back-to-menu-button'),
                    backFromCharSelect: document.getElementById('back-to-menu-from-char-select-button'),
                    backToMenuFromLobby: document.getElementById('back-to-menu-from-lobby-button'),
                    nextFromMapSelect: document.getElementById('next-from-map-select-button'),
                    backToMenuFromMapSelect: document.getElementById('back-to-menu-from-map-select-button'),
                    startVsAi: document.getElementById('start-vs-ai-button'),
                    backToLobbyFromWaiting: document.getElementById('back-to-lobby-from-waiting-button'),
                    // HUD et jeu
                    restart: document.getElementById('restart-button'),
                    specialAbility: document.getElementById('special-ability-button'),
                    mute: document.getElementById('mute-button'),
                    pause: document.getElementById('pause-button'),
                    resume: document.getElementById('resume-button'),
                    restartFromPause: document.getElementById('restart-from-pause-button'),
                    mainMenuFromPause: document.getElementById('main-menu-from-pause-button'),
                    confirmQuitYes: document.getElementById('confirm-quit-yes'),
                    confirmQuitNo: document.getElementById('confirm-quit-no'),
                    confirmUpgrade: document.getElementById('confirm-upgrade-button'),
                    armyPanelToggle: document.getElementById('army-panel-toggle'),
                    upgradePanelToggle: document.getElementById('upgrade-panel-toggle'),
                    connectToServer: document.getElementById('connect-to-server-button'),
                },
                inputs: {
                    // Nouveaux champs de saisie
                    createGamePassword: document.getElementById('create-game-password-input'),
                    joinGameCode: document.getElementById('join-game-code-input'),
                    serverUrl: document.getElementById('server-url-input'),
                    // ---
                    gameId: document.getElementById('game-id-input'), // Ancien champ, sera supprim√© du HTML plus tard
                    username: document.getElementById('username-input'),
                    password: document.getElementById('password-input'),
                },
                displays: {
                    globalWallet: document.getElementById('global-wallet-amount'),
                    level: document.getElementById('level-display'),
                    timer: document.getElementById('timer-display'),
                    killCount: document.getElementById('kill-count-display'),
                    wallet: document.getElementById('wallet-amount'),
                    hpBar: document.getElementById('hp-bar-fill'),
                    hpBarText: document.getElementById('hp-bar-text'),
                    specialCooldown: document.getElementById('special-cooldown-fill'),
                    levelUpOptions: document.getElementById('level-up-options'),
                    levelUpTitle: document.getElementById('level-up-title'),
                    gameOverStats: document.getElementById('game-over-stats'),
                    gameIdDisplay: document.getElementById('game-id-display'),
                    playerList: document.getElementById('player-list-in-waiting-room'),
                    authMessage: document.getElementById('auth-message'),
                    connectionStatus: document.getElementById('connection-status'),
                    xpBar: document.getElementById('xp-bar-fill'),
                    xpBarText: document.getElementById('xp-bar-text'),
                    playerQuadrant: document.getElementById('player-quadrant'),
                    bot1Quadrant: document.getElementById('bot1-quadrant'),
                    bot2Quadrant: document.getElementById('bot2-quadrant'),
                    bot3Quadrant: document.getElementById('bot3-quadrant'),
                    version: document.getElementById('version-display'),
                    // Copie des champs manquants depuis la lecture du fichier
                    charChoicesContainer: document.getElementById('character-choices-container'),
                    passiveUpgrades: document.getElementById('passive-upgrades-display'),
                    weaponUI: document.getElementById('weapon-display-ui'),
                    levelUpSubtitle: document.getElementById('level-up-subtitle'),
                    topHealthBarFill: document.getElementById('top-health-bar-fill'),
                    topHealthBarText: document.getElementById('top-health-bar-text'),
                    playerLevel: document.getElementById('player-level'),
                    playerWallet: document.getElementById('player-wallet'),
                    gameTimer: document.getElementById('game-timer'),
                    finalTime: document.getElementById('final-time'),
                    finalLevel: document.getElementById('final-level'),
                    finalGain: document.getElementById('final-gain'),
                    shopWallet: document.getElementById('shop-wallet-amount'),
                    shopItemsContainer: document.getElementById('shop-items-container'),
                    minimapCanvas: document.getElementById('minimap-canvas'),
                    bonusTimer: document.getElementById('bonus-timer'),
                    skillPoints: document.getElementById('skill-points-display'),
                    multiplayerUpgradesContainer: document.getElementById('multiplayer-upgrades-container'),
                    fusionTitle: document.getElementById('fusion-title'),
                    fusionOptionsContainer: document.getElementById('fusion-options-container'),
                    pentagramChargeContainer: document.getElementById('pentagram-charge-container'),
                    pentagramChargeBar: document.getElementById('pentagram-charge-bar'),
                },
                panels: {
                    armyPanel: document.getElementById('army-panel'),
                    upgradePanel: document.getElementById('multiplayer-upgrade-panel'),
                },
                gameHud: document.getElementById('game-hud'),
                joystick: {
                    zone: document.getElementById('joystick-zone'),
                    stick: document.getElementById('joystick-stick')
                }
            };

            // --- Configuration de la boutique ---
            const shopData = {
                damage: {
                    name: "Bonus de D√©g√¢ts",
                    icon: "‚ù§Ô∏è", // Sera rouge
                    levels: [
                        { bonus: 0.10, cost: 10000 },
                        { bonus: 0.20, cost: 30000 },
                        { bonus: 0.30, cost: 60000 },
                        { bonus: 0.50, cost: 180000 },
                        { bonus: 0.75, cost: 540000 },
                    ]
                },
                health: {
                    name: "Bonus de Vie",
                    icon: "üíö",
                    levels: [
                        { bonus: 0.10, cost: 10000 },
                        { bonus: 0.20, cost: 30000 },
                        { bonus: 0.30, cost: 60000 },
                        { bonus: 0.50, cost: 180000 },
                        { bonus: 0.75, cost: 540000 },
                    ]
                },
                xpGain: {
                    name: "Bonus de Gain d'XP",
                    icon: "üíô",
                    levels: [
                        { bonus: 0.10, cost: 10000 },
                        { bonus: 0.20, cost: 30000 },
                        { bonus: 0.30, cost: 60000 },
                        { bonus: 0.50, cost: 180000 },
                        { bonus: 0.75, cost: 540000 },
                    ]
                },
                attackSpeed: {
                    name: "Bonus de Vitesse d'Attaque",
                    icon: "üíõ",
                    levels: [
                        { bonus: 0.10, cost: 10000 }, // bonus = r√©duction du cooldown
                        { bonus: 0.20, cost: 30000 },
                        { bonus: 0.30, cost: 60000 },
                        { bonus: 0.50, cost: 180000 },
                        { bonus: 0.75, cost: 540000 },
                    ]
                }
            };

            const armyUnitData = {
                triangle: {
                    cost: 50,
                    shape: '‚ñ≤',
                    damage: 10,
                    fireRate: 1000, // ms
                    projectileSpeed: 4,
                    color: 'mvx'
                },
                square: {
                    cost: 100,
                    shape: '‚ñ†',
                    damage: 25,
                    fireRate: 1500,
                    projectileSpeed: 3,
                    color: 'sol'
                },
                rectangle: {
                    cost: 150,
                    shape: '‚ñ¨',
                    damage: 40,
                    fireRate: 2000,
                    projectileSpeed: 5,
                    color: 'eth'
                }
            };

            // --- Configuration des am√©liorations multijoueur ---
            let multiplayerUpgrades = {
                soldierDamage: {
                    name: "D√©g√¢ts Soldats",
                    icon: "üí•",
                    level: 0,
                    maxLevel: 10,
                    cost: 1,
                    bonus: 0.15 // +15% par niveau
                },
                soldierFireRate: {
                    name: "Cadence Soldats",
                    icon: "‚è±Ô∏è",
                    level: 0,
                    maxLevel: 10,
                    cost: 1,
                    bonus: 0.10 // -10% cooldown par niveau
                }
            };
            
            // --- CLASSES DU JEU ---

            class Vector {
                constructor(x = 0, y = 0) { this.x = x; this.y = y; }
                magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
                normalize() {
                    const mag = this.magnitude();
                    if (mag > 0) { this.x /= mag; this.y /= mag; }
                    return this;
                }
            }
            
            class Entity {
                constructor(x, y, radius) {
                    Object.assign(this, { x, y, radius });
                }
                update(dt) { /* a impl√©menter par les enfants */ }
                draw() { /* a impl√©menter par les enfants */ }
            }

            class Player extends Entity {
                constructor(charType, playerId = 1) {
                    super(0, 0, 15); // La position sera d√©finie dans resetGameState
                    this.playerId = playerId;
                    this.charType = charType;
                    const charData = characterData[this.charType];

                    // Application des bonus permanents
                    const permBonuses = getPermanentBonuses();
                    this.permanentDamageBonus = permBonuses.damage;
                    this.permanentHealthBonus = permBonuses.health;
                    this.permanentXpGainBonus = permBonuses.xpGain;
                    this.permanentCooldownBonus = permBonuses.attackSpeed;

                    // Stats de base
                    this.speed = 3;
                    this.speedMultiplier = 1.0;
                    this.baseMaxHp = 100;
                    this.maxHp = this.baseMaxHp * (1 + this.permanentHealthBonus);
                    this.hp = this.maxHp;
                    this.level = 1;
                    this.xp = 0;
                    this.xpToNextLevel = 10;
                    this.wallet = 0;
                    this.levelDamageBonus = 1.0; 
                    this.soldierOrbitAngle = 0; // Pour la formation des soldats
                    this.skillPoints = 0; // Pour le mode Army Attack
                    this.killCount = 0;
                    this.pentagramCharge = 0;
                    
                    // Armes et am√©liorations
                    this.weapons = [];
                    this.upgradesToPick = 0;
                    this.acquiredPassives = [];
                    this.extraUpgradeCharges = 0;
                    
                    // Multiplicateurs globaux
                    this.globalDamageMultiplier = 1.0;
                    this.globalCooldownMultiplier = 1.0;
                    this.projectileLifespanBonus = 1.0;
                    this.projectilePierceCount = 0;
                    this.xpGainBonus = 1.0; 
                    this.projectileCountBonus = 0;
                    this.pickupRadius = 50;
                    this.doubleXpChance = 0;
                    
                    // Multiplicateurs pour le super pouvoir
                    this.specialDamageMultiplier = 1.0;
                    this.specialCooldownMultiplier = 1.0;
                    this.specialAreaMultiplier = 1.0;

                    // √âtat
                    this.specialCooldown = 0;
                    this.isInvincible = false;
                    this.isBonusLevelUp = false;
                    if (this.isBonusLevelUp && this.level > 1) this.isBonusLevelUp = false; 
                    this.lastBossSpawnLevel = 0;
                    
                    // Propri√©t√©s du personnage
                    this.color = getComputedStyle(document.documentElement).getPropertyValue(charData.colorVar);
                    this.symbol = charData.symbol;
                    this.specialMaxCooldown = charData.cooldown;
                }

                update(dt) {
                    // Mouvement du joueur humain
                    const moveX = (inputManager.keys.left ? -1 : 0) + (inputManager.keys.right ? 1 : 0);
                    const moveY = (inputManager.keys.up ? -1 : 0) + (inputManager.keys.down ? 1 : 0);
                    const keyboardMove = new Vector(moveX, moveY).normalize();
                    const joystickMove = new Vector(inputManager.joystick.inputX, inputManager.joystick.inputY);
                    
                    let finalMove = (joystickMove.magnitude() > 0) ? joystickMove : keyboardMove;

                    this.x += finalMove.x * this.speed * this.speedMultiplier;
                    this.y += finalMove.y * this.speed * this.speedMultiplier;

                    // Limites du monde
                    const bounds = getQuadrantBoundaries(this.playerId);
                    this.x = Math.max(bounds.minX + this.radius, Math.min(bounds.maxX - this.radius, this.x));
                    this.y = Math.max(bounds.minY + this.radius, Math.min(bounds.maxY - this.radius, this.y));
                    
                    // Mise √† jour des armes et du cooldown
                    this.weapons.forEach(weapon => weapon.update(dt));
                    if (this.specialCooldown > 0) {
                        this.specialCooldown -= dt;
                        dom.buttons.specialAbility.classList.add('on-cooldown');
                    } else {
                        dom.buttons.specialAbility.classList.remove('on-cooldown');
                    }
                }

                draw() {
                    // Zone de collecte
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.pickupRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Invincibilit√©
                    if(this.isInvincible) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Joueur
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Symbole
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 20px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    if (this.charType === 'MVX') {
                        ctx.rotate(Math.PI / 2); // Rotation de 90 degr√©s
                    }
                    ctx.fillText(this.symbol, 0, 2);
                    ctx.restore();
                }
                
                takeDamage(amount) {
                    if (this.isInvincible) return;
                    audioManager.play('playerHit');
                    this.hp -= amount;
                    if (this.hp <= 0) {
                        this.hp = 0;
                        endGame(null); // Le joueur est le perdant, pas de gagnant en solo
                    }
                }

                gainXp(amount) {
                    const totalXpBonus = this.xpGainBonus * (1 + this.permanentXpGainBonus);
                    this.xp += amount * totalXpBonus;
                    if (activeMiniBoss) return;

                    while (this.xp >= this.xpToNextLevel) {
                        this.levelUp();
                    }
                }

                levelUp() {
                    audioManager.play('levelUp');
                    this.xp -= this.xpToNextLevel;
                    this.level++;
                    this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5);
                    
                    this.maxHp += 10;
                    this.hp = this.maxHp; 
                    
                    if (this.level % 5 === 0) {
                        this.levelDamageBonus += 0.05;
                        if (this.playerId === 1) createFloatingText('+5% D√©g√¢ts!', this.x, this.y, 'orange');
                    }
                    
                    if (this.playerId === 1) createFloatingText('LEVEL UP!', this.x, this.y, 'var(--xp-color)');
                    
                    const explosionRadius = 300;
                    const explosionDamage = 100 * 10;
                    entities.particles.push(new Particle(this.x, this.y, 'var(--primary-color)', explosionRadius, 500));
                    audioManager.play('explosion');
                    
                    entities.enemies.forEach(e => {
                        if (Math.hypot(this.x - e.x, this.y - e.y) < explosionRadius) {
                            if (e instanceof MiniBoss) {
                                e.takeDamage(explosionDamage);
                            } else {
                                e.hp = 0;
                            }
                        }
                    });

                    if (gameMode === 'armyAttack') {
                        this.skillPoints = (this.skillPoints || 0) + 1;
                        if (this.playerId === 1) {
                            updateAllUI();
                            createFloatingText('+1 Point!', this.x, this.y, 'gold');
                        }
                    } else {
                        gameState = 'levelUp';
                        this.upgradesToPick = 1; 
                        showLevelUpOptions();
                    }
                }

                addWeapon(weapon) {
                    this.weapons.push(weapon);
                    updateWeaponDisplay();
                }

                useSpecial() {
                    if (this.specialCooldown <= 0 && players[0]) {
                        this.specialCooldown = this.specialMaxCooldown * this.specialCooldownMultiplier;
                        characterData[this.charType].special(this);
                    }
                }
            }

            class BotPlayer extends Player {
                constructor(charType, playerId) {
                    super(charType, playerId);
                    this.optimalRange = 200;
                    this.purchaseTimer = 5000 + Math.random() * 5000;
                }

                update(dt) {
                    if (this.hp <= 0) return;

                    // --- AI Decision Making & Movement ---
                    const enemiesInQuadrant = entities.enemies.filter(e => e.quadrant === this.playerId && e.hp > 0);
                    let finalMove = new Vector(0, 0);

                    if (enemiesInQuadrant.length > 0) {
                        let repulsion = new Vector(0, 0);
                        let attraction = new Vector(0, 0);
                        const DANGER_RADIUS = 120;
                        const WALL_AVOID_RADIUS = 60;

                        // 1. Repulsion from all nearby enemies
                        enemiesInQuadrant.forEach(enemy => {
                            const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                            if (dist < DANGER_RADIUS) {
                                let fleeVector = new Vector(this.x - enemy.x, this.y - enemy.y);
                                fleeVector.normalize();
                                // La force de r√©pulsion est inversement proportionnelle √† la distance
                                fleeVector.x /= (dist + 0.1); 
                                fleeVector.y /= (dist + 0.1);
                                repulsion.x += fleeVector.x;
                                repulsion.y += fleeVector.y;
                            }
                        });

                        // 2. Attraction/Repulsion to the closest enemy to maintain optimal range
                        const closestEnemy = enemiesInQuadrant.reduce((closest, enemy) => {
                            const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                            return dist < closest.dist ? { dist, enemy } : closest;
                        }, { dist: Infinity }).enemy;

                        if (closestEnemy) {
                            const distToClosest = Math.hypot(this.x - closestEnemy.x, this.y - closestEnemy.y);
                            if (distToClosest > this.optimalRange) { // Trop loin, on s'approche
                                attraction.x = closestEnemy.x - this.x;
                                attraction.y = closestEnemy.y - this.y;
                            } else { // Trop pr√®s, on recule
                                attraction.x = this.x - closestEnemy.x;
                                attraction.y = this.y - closestEnemy.y;
                            }
                        }
                        
                        // 3. Wall Avoidance
                        const bounds = getQuadrantBoundaries(this.playerId);
                        if (this.x < bounds.minX + WALL_AVOID_RADIUS) repulsion.x += 1;
                        if (this.x > bounds.maxX - WALL_AVOID_RADIUS) repulsion.x -= 1;
                        if (this.y < bounds.minY + WALL_AVOID_RADIUS) repulsion.y += 1;
                        if (this.y > bounds.maxY - WALL_AVOID_RADIUS) repulsion.y -= 1;

                        // 4. Combine forces (giving much more weight to repulsion)
                        repulsion.normalize();
                        attraction.normalize();
                        finalMove.x = (repulsion.x * 2.0) + (attraction.x * 0.8);
                        finalMove.y = (repulsion.y * 2.0) + (attraction.y * 0.8);

                    } 
                    
                    finalMove.normalize();
                    this.x += finalMove.x * this.speed * 0.7;
                    this.y += finalMove.y * this.speed * 0.7;

                    // --- AI Purchasing ---
                    this.purchaseTimer -= dt;
                    if (this.purchaseTimer <= 0) {
                        const soldiersOwned = entities.soldiers.filter(s => s.owner === this).length;
                        if (soldiersOwned < 10) { // Max 10 soldiers
                             const unitTypes = Object.keys(armyUnitData);
                             const randomUnitType = unitTypes[Math.floor(Math.random() * unitTypes.length)];
                             const cost = armyUnitData[randomUnitType].cost;
                             if (this.wallet >= cost) {
                                 this.wallet -= cost;
                                 const spawnX = this.x + (Math.random() - 0.5) * 40;
                                 const spawnY = this.y + (Math.random() - 0.5) * 40;
                                 entities.soldiers.push(new Soldier(spawnX, spawnY, this, randomUnitType));
                             }
                        }
                        this.purchaseTimer = 10000 + Math.random() * 5000; // Reset timer
                    }


                    // Limites du monde (clamp position to be safe)
                    const bounds = getQuadrantBoundaries(this.playerId);
                    this.x = Math.max(bounds.minX + this.radius, Math.min(bounds.maxX - this.radius, this.x));
                    this.y = Math.max(bounds.minY + this.radius, Math.min(bounds.maxY - this.radius, this.y));

                    // Mise √† jour des armes
                    this.weapons.forEach(weapon => weapon.update(dt));
                }

                draw() {
                    super.draw(); // Dessine le joueur normalement
                    // Ajoute une indication "BOT"
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(`BOT ${this.playerId}`, this.x, this.y - this.radius - 5);
                }
            }
            
            class Enemy extends Entity {
                constructor(tier = 0, x, y, quadrant) {
                    super(x, y, 12);
                    this.quadrant = quadrant;
                    this.bounds = getQuadrantBoundaries(this.quadrant);
                    
                    const tierData = bossProgression[tier];
                    this.tier = tier;
                    this.speed = 1 + Math.random() * 0.5 + tier * 0.3;
                    this.hp = 20 * Math.pow(11, tier);
                    this.damage = 5 * Math.pow(1.5, tier);
                    this.walletValue = 1 * (tier + 1);
                    this.xpValue = 1 * Math.pow(6, tier);
                    this.color = getComputedStyle(document.documentElement).getPropertyValue(tierData.colorVar);
                    this.symbol = tierData.symbol;
                    this.hitTimer = 0;
                    this.targetPlayer = players.find(p => p.playerId === this.quadrant);
                }

                update(dt) {
                    if (this.hitTimer > 0) {
                        this.hitTimer -= dt;
                    }
                    
                    if (!this.targetPlayer || this.targetPlayer.hp <= 0) {
                        return; // Arr√™te de bouger si la cible est morte
                    }

                    const angle = Math.atan2(this.targetPlayer.y - this.y, this.targetPlayer.x - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;

                    // Respecter les murs du quadrant
                    this.x = Math.max(this.bounds.minX + this.radius, Math.min(this.bounds.maxX - this.radius, this.x));
                    this.y = Math.max(this.bounds.minY + this.radius, Math.min(this.bounds.maxY - this.radius, this.y));
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    if (this.hitTimer > 0) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.symbol, this.x, this.y);
                }

                takeDamage(amount) {
                    this.hp -= amount;
                    this.hitTimer = 100;
                    if (this.hp <= 0) {
                        const killer = players.find(p => p.playerId === this.quadrant);
                        if (killer) {
                           killer.wallet += this.walletValue;
                           killer.killCount++;
                           if (killer.playerId === 1) { // Only human player gets XP
                                audioManager.play('enemyDefeat');
                                const isDouble = Math.random() < killer.doubleXpChance;
                                entities.xpOrbs.push(new XpOrb(this.x, this.y, this.xpValue, isDouble));
                           }
                        }
                    }
                }
            }

            class TankEnemy extends Enemy {
                constructor(tier = 0, x, y, quadrant) {
                    super(tier, x, y, quadrant); 
                    this.radius = 18;
                    this.hp = 500 * Math.pow(11, tier);
                    this.xpValue *= 4;
                }
            }
            
            class MiniBoss extends Enemy {
                constructor(tier, x, y, quadrant, isDemiBoss = false) {
                    super(tier, x, y, quadrant); 
                    this.isDemiBoss = isDemiBoss;
                    const tierData = bossProgression[tier];
                    this.name = tierData.name;
                    this.radius = isDemiBoss ? 25 : 40;
                    this.hp = (isDemiBoss ? 1000 : 3000) * Math.pow(11, tier);
                    this.maxHp = this.hp;
                    this.xpValue = (isDemiBoss ? 15 : 50) * Math.pow(6, tier);
                    this.walletValue = (isDemiBoss ? 25 : 100) * (tier + 1);
                    this.speed *= 1.25;
                    
                    this.spikeRotation1 = 0;
                    this.spikeRotation2 = 0;
                    this.spikeAnimationTimer = 0;
                }

                update(dt) {
                    // La logique de ciblage du parent est globale, ce qui est ok pour un boss
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    this.targetPlayer = humanPlayer;
                    super.update(dt);
                    this.spikeRotation1 += 0.02; 
                    this.spikeRotation2 -= 0.03;
                    this.spikeAnimationTimer += dt;
                }

                draw() {
                    // ... (le dessin du boss reste le m√™me)
                }

                takeDamage(amount) {
                    this.hp -= amount;
                    this.hitTimer = 100;
                    if (this.hp <= 0) {
                        const humanPlayer = players[0];
                        audioManager.play('enemyDefeat');
                        audioManager.playMusic('game');
                        if (!this.isDemiBoss && !unlockedCharacters.includes(this.name)) {
                            unlockedCharacters.push(this.name);
                            saveGameState();
                            createFloatingText(`${this.name} d√©bloqu√©!`, humanPlayer.x, humanPlayer.y, 'gold');
                        }
                        humanPlayer.isBonusLevelUp = true;
                        entities.xpOrbs.push(new XpOrb(this.x, this.y, this.xpValue, true));
                        humanPlayer.wallet += this.walletValue;
                        activeMiniBoss = null;

                        while (humanPlayer.xp >= humanPlayer.xpToNextLevel) {
                            humanPlayer.levelUp();
                        }
                    }
                }
            }
            
            class Projectile extends Entity {
                constructor(x, y, radius, { angle, speed, damage, lifespan, color = 'white', pierce = 0 }) {
                    super(x, y, radius);
                    Object.assign(this, { angle, speed, damage, lifespan, color, pierce });
                }
                update(dt) {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    this.lifespan -= dt;
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            class Rocket extends Projectile {
                constructor(x, y, owner) {
                    const options = { angle: 0, speed: 4, damage: 0, lifespan: 5000 };
                    super(x, y, 12, options);
                    this.owner = owner;
                    this.findNewTarget();
                }

                findNewTarget() {
                    this.target = entities.enemies.length > 0 ? entities.enemies.reduce((closest, enemy) => {
                        if (enemy.hp <= 0) return closest;
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        return dist < closest.dist ? { dist, enemy } : closest;
                    }, { dist: Infinity }).enemy : null;
                }

                update(dt) {
                    if (!this.target || this.target.hp <= 0 || !entities.enemies.includes(this.target)) {
                        this.findNewTarget();
                    }

                    if (this.target) {
                        this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    }
                    
                    super.update(dt);
                    if (this.lifespan <= 0) this.explode();
                }

                onHit() { this.explode(); }

                explode() {
                    if (this.lifespan <= 0) return;
                    audioManager.play('explosion');
                    this.lifespan = 0; 
                    const explosionRadius = 80 * this.owner.specialAreaMultiplier;
                    entities.particles.push(new Particle(this.x, this.y, 'cyan', explosionRadius, 400));
                    entities.enemies.forEach(enemy => {
                        if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < explosionRadius) {
                            enemy.takeDamage(100 * this.owner.globalDamageMultiplier * (1 + this.owner.permanentDamageBonus) * this.owner.levelDamageBonus * this.owner.specialDamageMultiplier);
                        }
                    });
                }

                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle + Math.PI / 2);
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üöÄ', 0, 0);
                    ctx.restore();
                }
            }

            class XpOrb extends Entity {
                 constructor(x, y, value, isDouble = false) {
                    super(x, y, isDouble ? 7 : 5);
                    this.value = isDouble ? value * 2 : value;
                    this.color = isDouble ? 'var(--double-xp-color)' : 'var(--xp-color)';
                    this.isAttracted = false;
                }
                update(dt) {
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    if (this.isAttracted || Math.hypot(humanPlayer.x - this.x, humanPlayer.y - this.y) < humanPlayer.pickupRadius) {
                        this.isAttracted = true;
                        const angle = Math.atan2(humanPlayer.y - this.y, humanPlayer.x - this.x);
                        this.x += Math.cos(angle) * 8;
                        this.y += Math.sin(angle) * 8;
                    }
                }
                draw() {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue(this.color.replace(/var\(|\)/g, ''));
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            class HealthPickup extends Entity {
                constructor(x, y) {
                    super(x, y, 12);
                    this.lifespan = 30000;
                    this.healAmount = 25;
                    this.isAttracted = false;
                }
                update(dt) {
                    this.lifespan -= dt;
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    if (this.isAttracted || Math.hypot(humanPlayer.x - this.x, humanPlayer.y - this.y) < humanPlayer.pickupRadius) {
                        this.isAttracted = true;
                        const angle = Math.atan2(humanPlayer.y - this.y, humanPlayer.x - this.x);
                        this.x += Math.cos(angle) * 8;
                        this.y += Math.sin(angle) * 8;
                    }
                }
                draw() {
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('‚ù§Ô∏è', this.x, this.y);
                }
            }

            class FloatingText extends Entity {
                constructor(text, x, y, color) {
                    super(x,y,0);
                    this.text = text;
                    this.color = color;
                    this.lifespan = 1000;
                    this.initialLifespan = 1000;
                }
                update(dt) {
                    this.y -= 0.5;
                    this.lifespan -= dt;
                }
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.lifespan / this.initialLifespan;
                    ctx.fillStyle = this.color.startsWith('var') ? getComputedStyle(document.documentElement).getPropertyValue(this.color.replace(/var\(|\)/g, '')) : this.color;
                    ctx.font = 'bold 18px Poppins';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                }
            }
            
            class Particle extends Entity {
                 constructor(x, y, color, size, lifespan) {
                    super(x,y,0);
                    this.color = color;
                    this.size = size;
                    this.lifespan = lifespan;
                    this.initialLifespan = lifespan;
                }
                update(dt) {
                    this.lifespan -= dt;
                }
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.lifespan / this.initialLifespan;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * (1 - (this.lifespan / this.initialLifespan)), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            class Magnet extends Entity {
                constructor(x, y) {
                    super(x, y, 12);
                    this.lifespan = 30000;
                    this.isAttracted = false;
                }
                update(dt) {
                    this.lifespan -= dt;
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    if (this.isAttracted || Math.hypot(humanPlayer.x - this.x, humanPlayer.y - this.y) < humanPlayer.pickupRadius) {
                        this.isAttracted = true;
                        const angle = Math.atan2(humanPlayer.y - this.y, humanPlayer.x - this.x);
                        this.x += Math.cos(angle) * 8;
                        this.y += Math.sin(angle) * 8;
                    }
                }
                draw() {
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üß≤', this.x, this.y);
                }
            }

            class BonusUpgrade extends Entity {
                constructor(x, y) {
                    super(x, y, 12);
                    this.lifespan = 30000; // 30 secondes
                    this.isAttracted = false;
                }
                update(dt) {
                    this.lifespan -= dt;
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    if (this.isAttracted || Math.hypot(humanPlayer.x - this.x, humanPlayer.y - this.y) < humanPlayer.pickupRadius) {
                        this.isAttracted = true;
                        const angle = Math.atan2(humanPlayer.y - this.y, humanPlayer.x - this.x);
                        this.x += Math.cos(angle) * 8;
                        this.y += Math.sin(angle) * 8;
                    }
                }
                draw() {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 24px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('+', this.x, this.y);
                }
            }

            class Soldier extends Entity {
                constructor(x, y, owner, unitType, fusionLevel = 0) {
                    super(x, y, 10 + fusionLevel * 0.5);
                    this.owner = owner;
                    this.unitType = unitType;
                    this.fusionLevel = fusionLevel;
                    this.stats = armyUnitData[unitType];
                    this.color = getComputedStyle(document.documentElement).getPropertyValue(`--${this.stats.color}-color`);
                    this.fireTimer = this.getFireRate();
                    this.target = null;
                    // Propri√©t√©s pour le mouvement en formation
                    this.orbitAngle = owner.soldierOrbitAngle;
                    owner.soldierOrbitAngle += Math.PI / 4; // Espace les soldats
                    this.orbitRadius = 50 + (Math.random() * 20 - 10); // Un peu de variation
                    this.moveSpeed = 2.8; // Un peu plus lent que le joueur
                }

                getDamage() {
                    const skillBonus = multiplayerUpgrades.soldierDamage.level * multiplayerUpgrades.soldierDamage.bonus;
                    const fusionBonus = this.fusionLevel * 0.5; // +50% damage per fusion level
                    return this.stats.damage * (1 + skillBonus) * (1 + fusionBonus);
                }

                getFireRate() {
                    const bonus = multiplayerUpgrades.soldierFireRate.level * multiplayerUpgrades.soldierFireRate.bonus;
                    return this.stats.fireRate * (1 - bonus);
                }

                findTarget() {
                    const enemiesInQuadrant = entities.enemies.filter(e => e.quadrant === this.owner.playerId);
                    if (enemiesInQuadrant.length === 0) {
                        this.target = null;
                        return;
                    }

                    let closestDist = Infinity;
                    let closestEnemy = null;
                    enemiesInQuadrant.forEach(enemy => {
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    });
                    this.target = closestEnemy;
                }

                update(dt) {
                    // --- Logique de mouvement pour suivre le joueur ---
                    const targetX = this.owner.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                    const targetY = this.owner.y + Math.sin(this.orbitAngle) * this.orbitRadius;

                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const dist = Math.hypot(dx, dy);

                    // Se d√©place vers la position en orbite si n'est pas d√©j√† assez proche
                    if (dist > 1) {
                        this.x += (dx / dist) * this.moveSpeed;
                        this.y += (dy / dist) * this.moveSpeed;
                    }
                    
                    // --- Logique de tir ---
                    this.fireTimer -= dt;

                    if (!this.target || this.target.hp <= 0) {
                        this.findTarget();
                    }

                    if (this.target && this.fireTimer <= 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const p_options = { angle, speed: this.stats.projectileSpeed, damage: this.getDamage(), lifespan: 1200, color: this.color, pierce: 0 };
                        entities.projectiles.push(new Projectile(this.x, this.y, 4, p_options));
                        
                        this.fireTimer = this.getFireRate();
                    }

                    // Garder le soldat dans le quadrant
                    const bounds = getQuadrantBoundaries(this.owner.playerId);
                    this.x = Math.max(bounds.minX + this.radius, Math.min(bounds.maxX - this.radius, this.x));
                    this.y = Math.max(bounds.minY + this.radius, Math.min(bounds.maxY - this.radius, this.y));
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 12px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.stats.shape, this.x, this.y + 1);

                    if (this.fusionLevel > 0) {
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 10px "Roboto Mono"';
                        ctx.fillText(this.fusionLevel, this.x, this.y + 1);
                    }
                }
            }
            
            // --- Classe Missile pour d√©g√¢ts de zone ---
            class Missile extends Projectile {
                constructor(x, y, radius, options) {
                    super(x, y, radius, options);
                    this.explosionRadius = 40;
                }

                update(dt) {
                    super.update(dt);
                    // Si la dur√©e de vie est √©coul√©e, explose
                    if (this.lifespan <= 0) {
                        this.explode();
                    }
                }

                onHit() {
                    this.explode();
                }

                explode() {
                    if (this.lifespan <= -1) return; // Emp√™che les explosions multiples
                    
                    audioManager.play('explosion');
                    entities.particles.push(new Particle(this.x, this.y, this.color, this.explosionRadius, 300));
                    
                    entities.enemies.forEach(enemy => {
                        if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < this.explosionRadius) {
                            enemy.takeDamage(this.damage);
                        }
                    });
                    
                    this.lifespan = -1; // Marque le projectile pour suppression
                }
            }

            class Pentagram extends Entity {
                constructor(x, y, owner) {
                    super(x, y, 60);
                    this.owner = owner;
                    this.lifespan = 20000; // Dure 20 secondes
                    this.rotation = 0;
                }

                update(dt) {
                    this.lifespan -= dt;
                    this.rotation += 0.01;
                }

                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.strokeStyle = 'rgba(255, 65, 77, 0.8)';
                    ctx.lineWidth = 3;

                    // Cercle ext√©rieur
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // √âtoile
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                        const x = Math.cos(angle) * this.radius;
                        const y = Math.sin(angle) * this.radius;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }


            // --- CLASSES D'ARMES ET LISTES D'AM√âLIORATIONS ---
            const progression = [1, 1.25, 1.5, 2.0, 3.0, 5.0]; // Niveaux 0-5.
            
            class Weapon {
                constructor(player, key) {
                    this.player = player;
                    this.key = key; // Pour retrouver les infos dans weaponList
                    this.level = 1; // Commence au niveau 1
                    this.timer = 0;
                    this.maxLevel = 5;
                }
                update(dt) {
                    this.timer -= dt;
                    if (this.timer <= 0) {
                        this.fire();
                        this.timer = this.getCooldown();
                    }
                }
                getCooldown() { 
                    const totalCooldownBonus = this.player.globalCooldownMultiplier * (1 - this.player.permanentCooldownBonus);
                    return this.baseCooldown * (1 / progression[this.level]) * totalCooldownBonus; 
                }
                getDamage() { 
                    const totalDamageBonus = this.player.globalDamageMultiplier * (1 + this.player.permanentDamageBonus) * this.player.levelDamageBonus;
                    return this.baseDamage * progression[this.level] * totalDamageBonus; 
                }
                fire() { /* Impl√©ment√© par les sous-classes */ }
                upgrade() { if(this.level < this.maxLevel) this.level++; }
            }

            class BuyGun extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 800;
                    this.baseDamage = 8;
                }
                fire() {
                    if (entities.enemies.length === 0) return;
                    
                    const enemiesInQuadrant = entities.enemies.filter(e => e.quadrant === this.player.playerId);
                    if (enemiesInQuadrant.length === 0) return;

                    audioManager.play('shoot');
                    let closestEnemy = enemiesInQuadrant.reduce((closest, enemy) => {
                        const dist = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);
                        return dist < closest.dist ? { dist, enemy } : closest;
                    }, { dist: Infinity }).enemy;

                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - this.player.y, closestEnemy.x - this.player.x);
                        const p_options = { angle, speed: 5, damage: this.getDamage(), lifespan: 1000 * this.player.projectileLifespanBonus, pierce: this.player.projectilePierceCount };
                        entities.projectiles.push(new Projectile(this.player.x, this.player.y, 4, p_options));
                    }
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente d√©g√¢ts et cadence.`; }
            }
            
            class FomoGun extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 150;
                    this.baseDamage = 4;
                }
                fire() {
                     if (entities.enemies.length === 0) return;
                    audioManager.play('shoot');
                    let closestEnemy = entities.enemies.reduce((closest, enemy) => {
                        const dist = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);
                        return dist < closest.dist ? { dist, enemy } : closest;
                    }, { dist: Infinity }).enemy;

                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - this.player.y, closestEnemy.x - this.player.x);
                        const p_options = { angle, speed: 7, damage: this.getDamage(), lifespan: 800 * this.player.projectileLifespanBonus, pierce: this.player.projectilePierceCount };
                        entities.projectiles.push(new Projectile(this.player.x, this.player.y, 3, p_options));
                    }
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente d√©g√¢ts et cadence.`; }
            }

            class SpiralGun extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 400;
                    this.baseDamage = 5;
                    this.spiralAngle = 0;
                }
                fire() {
                    audioManager.play('shoot');
                    const totalProjectiles = 4;
                    for(let i=0; i<totalProjectiles; i++) {
                        const angle = (Math.PI*2 / totalProjectiles * i) + this.spiralAngle;
                        const p_options = { angle, speed: 3, damage: this.getDamage(), lifespan: 1500 * this.player.projectileLifespanBonus, pierce: this.player.projectilePierceCount };
                        entities.projectiles.push(new Projectile(this.player.x, this.player.y, 3, p_options));
                    }
                    this.spiralAngle += Math.PI / 16;
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente les d√©g√¢ts.`; }
            }
            
            class LaserGun extends Weapon {
                constructor(player, key, angle, color) {
                    super(player, key);
                    this.baseCooldown = 4000;
                    this.baseDamage = 0.5; // D√©g√¢ts par tick
                    this.angle = angle;
                    this.color = color;
                    this.baseWidth = 10;
                }
                getWidth() { return this.baseWidth * progression[this.level]; }
                fire() {
                    audioManager.play('shoot');
                    const laser = new LaserBeam(this.player.x, this.player.y, this.angle, this.color, this.getWidth(), this.getDamage(), this.player);
                    entities.projectiles.push(laser);
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente largeur et d√©g√¢ts.`; }
            }
            
            class PowerRangeGun extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 4000;
                    this.baseDamage = 0.5; // D√©g√¢ts par tick
                    this.color = 'orange';
                    this.baseWidth = 10;
                }
                getWidth() { return this.baseWidth * progression[this.level]; }
                fire() {
                    audioManager.play('shoot');
                    const damage = this.getDamage();
                    const width = this.getWidth();
                    // Laser vers la droite
                    entities.projectiles.push(new LaserBeam(this.player.x, this.player.y, 0, this.color, width, damage, this.player));
                    // Laser vers la gauche
                    entities.projectiles.push(new LaserBeam(this.player.x, this.player.y, Math.PI, this.color, width, damage, this.player));
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente largeur et d√©g√¢ts.`; }
            }


            class LaserBeam extends Projectile {
                constructor(x, y, angle, color, width, damage, owner) {
                    super(x, y, 0, { angle, speed: 0, damage, lifespan: 200, color });
                    this.width = width;
                    this.owner = owner;
                }
                update(dt) {
                    super.update(dt);
                    if (!this.owner) { this.lifespan = 0; return; }
                    this.x = this.owner.x; // Le laser suit le joueur
                    this.y = this.owner.y;
                    // Appliquer les d√©g√¢ts aux ennemis dans la zone
                    entities.enemies.forEach(e => {
                        const dx = e.x - this.x;
                        const dy = e.y - this.y;
                        const projectedDist = dx * Math.cos(this.angle) + dy * Math.sin(this.angle);
                        const perpDist = Math.abs(dx * Math.sin(this.angle) - dy * Math.cos(this.angle));
                        if(projectedDist > 0 && perpDist < this.width / 2) {
                            e.takeDamage(this.damage);
                        }
                    });
                }
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.globalAlpha = this.lifespan / 200;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(0, -this.width / 2, 2000, this.width);
                    ctx.restore();
                }
            }

            class MineLayer extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 5000;
                    this.baseDamage = 50;
                    this.baseRadius = 60;
                }
                getExplosionRadius() { return this.baseRadius * progression[this.level]; }
                fire() {
                    const mine = new Mine(this.player.x, this.player.y, this.getDamage(), this.getExplosionRadius());
                    entities.projectiles.push(mine);
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente d√©g√¢ts et rayon d'explosion.`; }
            }

            class Mine extends Projectile {
                constructor(x, y, damage, explosionRadius) {
                    super(x, y, 8, { angle: 0, speed: 0, damage, lifespan: 2000, color: 'orange' });
                    this.explosionRadius = explosionRadius;
                }
                update(dt) {
                    this.lifespan -= dt;
                    if (this.lifespan <= 0) this.explode();
                }
                explode() {
                    if(this.lifespan > -1000) { // Pour √©viter les explosions multiples
                        this.lifespan = -1001;
                        audioManager.play('explosion');
                        entities.particles.push(new Particle(this.x, this.y, 'orange', this.explosionRadius, 400));
                        entities.enemies.forEach(e => { 
                            if(Math.hypot(this.x - e.x, this.y - e.y) < this.explosionRadius) {
                                e.takeDamage(this.damage);
                            }
                        });
                    }
                }
            }
            
            class MagnetismAura extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.applyBonus(); // Applique le bonus initial
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    // Chaque niveau augmente le rayon en se basant sur le tableau de progression
                    this.player.pickupRadius = 50 * progression[this.level];
                }

                getUpgradeDescription() {
                    return `Niv ${this.level + 1}: Augmente le rayon d'attraction des orbes.`;
                }
            }

            class LiquidationWave extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.pierceLevels = [1, 2, 4, 8, 16];
                    this.applyBonus();
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    this.player.projectilePierceCount = this.pierceLevels[this.level - 1];
                }

                getUpgradeDescription() {
                    const nextPierce = this.level < this.maxLevel ? this.pierceLevels[this.level] : this.pierceLevels[this.level - 1];
                    return `Niv ${this.level + 1}: Les projectiles traversent ${nextPierce} ennemis.`;
                }
            }

            class Supertrader extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.bonuses = [
                        { damage: 1.10, cooldown: 0.90, area: 1.10 }, // Level 1
                        { damage: 1.20, cooldown: 0.80, area: 1.20 }, // Level 2
                        { damage: 1.30, cooldown: 0.70, area: 1.30 }, // Level 3
                        { damage: 1.50, cooldown: 0.60, area: 1.60 }, // Level 4
                        { damage: 2.00, cooldown: 0.50, area: 2.00 }, // Level 5
                    ];
                    this.applyBonus();
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    const bonus = this.bonuses[this.level - 1];
                    this.player.specialDamageMultiplier = bonus.damage;
                    this.player.specialCooldownMultiplier = bonus.cooldown;
                    this.player.specialAreaMultiplier = bonus.area;
                }

                getUpgradeDescription() {
                    if (this.level >= this.maxLevel) return "Niveau maximum atteint.";
                    const nextBonus = this.bonuses[this.level];
                    return `Niv ${this.level + 1}: +${Math.round((nextBonus.damage-1)*100)}% D√©g√¢ts, -${Math.round((1-nextBonus.cooldown)*100)}% Cooldown, +${Math.round((nextBonus.area-1)*100)}% Zone`;
                }
            }

            const weaponList = {
                buy: { name: "Buy", description: "Tire un projectile de base.", icon: 'üî´', init: (p) => new BuyGun(p, 'buy') },
                fomo: { name: "Fomo", description: "Mitraillette rapide, d√©g√¢ts r√©duits.", icon: '‚öôÔ∏è', init: (p) => new FomoGun(p, 'fomo') },
                spiral: { name: "Cercle Fibonacci", description: "Tirs en spirale.", icon: 'üåÄ', init: (p) => new SpiralGun(p, 'spiral') },
                powerRange: { name: "Power Range", description: "Lasers horizontaux.", icon: '‚ÜîÔ∏è', init: (p) => new PowerRangeGun(p, 'powerRange') },
                toTheMoon: { name: "To The Moon", description: "Laser vertical vers le haut.", icon: 'üü¢', init: (p) => new LaserGun(p, 'toTheMoon', -Math.PI/2, 'lime') },
                toTheHell: { name: "To The Hell", description: "Laser vertical vers le bas.", icon: 'üî¥', init: (p) => new LaserGun(p, 'toTheHell', Math.PI/2, 'red') },
                eclatement: { name: "Eclatement", description: "Pose des mines explosives.", icon: 'üí£', init: (p) => new MineLayer(p, 'eclatement') },
                magnetism: { name: "Aura Magn√©tique", description: "Augmente le rayon d'attraction des orbes.", icon: 'üß≤', init: (p) => new MagnetismAura(p, 'magnetism') },
                liquidation: { name: "Vague de Liquidations", description: "Les projectiles traversent les ennemis.", icon: 'üåä', init: (p) => new LiquidationWave(p, 'liquidation') },
                supertrader: { name: "Supertrader", description: "Am√©liore la capacit√© sp√©ciale.", icon: 'üíπ', init: (p) => new Supertrader(p, 'supertrader') },
            };

            const passiveUpgrades = {
                damage: { 
                    name: "Puissance de Feu", icon: 'üí•',
                    apply: (p, bonus) => { p.globalDamageMultiplier *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                },
                range: { 
                    name: "Long HODL", icon: 'üî≠',
                    apply: (p, bonus) => { p.projectileLifespanBonus *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                },
                xpGain: { 
                    name: "Airdrop d'XP", icon: 'üéì',
                    apply: (p, bonus) => { p.xpGainBonus *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                }
            };
            
            // --- Fonctions de sauvegarde et chargement ---
            function saveGameState() {
                const state = {
                    globalWallet,
                    unlockedCharacters,
                    permanentUpgrades
                };
                localStorage.setItem('cryptoSurvivorSave', JSON.stringify(state));
            }

            function loadGameState() {
                const savedState = localStorage.getItem('cryptoSurvivorSave');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    globalWallet = state.globalWallet || 0;
                    unlockedCharacters = state.unlockedCharacters || ['MVX'];
                    permanentUpgrades = state.permanentUpgrades || { damage: 0, health: 0, xpGain: 0, attackSpeed: 0 };
                }
            }

            function getPermanentBonuses() {
                const bonuses = { damage: 0, health: 0, xpGain: 0, attackSpeed: 0 };
                for (const key in permanentUpgrades) {
                    const level = permanentUpgrades[key];
                    if (level > 0) {
                        bonuses[key] = shopData[key].levels[level - 1].bonus;
                    }
                }
                return bonuses;
            }


            // --- FONCTIONS DE LOGIQUE DE JEU ---

            function init() {
                loadGameState(); // Charger les donn√©es au d√©marrage
                updateZoom();
                resizeCanvas();
                setupEventListeners();
                setupCharacterSelection();
            }
            
            function setupEventListeners() {
                window.addEventListener('resize', resizeCanvas);
                
                dom.buttons.startGame.addEventListener('click', async () => {
                    await audioManager.initialize(); // Initialise l'audio au premier clic
                    audioManager.playMusic('menu');
                    gameState = 'characterSelection';
                    setupCharacterSelection(); // Mettre √† jour les persos d√©bloqu√©s
                    showScreen('characterSelection');
                });
                
                dom.buttons.multiplayer.addEventListener('click', () => {
                    showScreen('multiplayerMode');
                });

                dom.buttons.connectToServer.addEventListener('click', () => {
                    const serverUrl = dom.inputs.serverUrl.value.trim();
                    if (serverUrl) {
                        initializeSocket(serverUrl);
                    } else {
                        dom.displays.connectionStatus.textContent = 'Veuillez entrer une URL de serveur.';
                        dom.displays.connectionStatus.style.color = 'orange';
                    }
                });

                dom.buttons.shop.addEventListener('click', async () => {
                     await audioManager.initialize();
                     audioManager.playMusic('menu');
                     displayShop();
                     showScreen('shop');
                });

                dom.buttons.backToMenu.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    showScreen('mainMenu');
                });
                
                dom.buttons.backFromCharSelect.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    showScreen('mainMenu');
                });
                
                dom.buttons.backToMenuFromLobby.addEventListener('click', () => {
                    showScreen('mapSelection');
                });
                
                dom.buttons.backToLobbyFromWaiting.addEventListener('click', () => {
                    showScreen('multiplayerLobby');
                });

                dom.buttons.backToMenuFromMapSelect.addEventListener('click', () => {
                    showScreen('multiplayerMode');
                });
                
                dom.buttons.backToMainMenuFromMultiplayerMode.addEventListener('click', () => {
                    showScreen('mainMenu');
                });

                dom.buttons.backToMultiplayerModeFromCreate.addEventListener('click', () => {
                    showScreen('multiplayerMode');
                });

                dom.buttons.backToMultiplayerModeFromJoin.addEventListener('click', () => {
                    showScreen('multiplayerMode');
                });
                
                dom.buttons.armyAttack.addEventListener('click', () => {
                    showScreen('mapSelection');
                });

                dom.buttons.nextFromMapSelect.addEventListener('click', () => {
                    if (selectedMap) {
                        const lobbyPlayerName = document.getElementById('lobby-player-name');
                        if (lobbyPlayerName && currentPlayer) {
                            lobbyPlayerName.textContent = currentPlayer.username;
                        }
                        showScreen('multiplayerLobby');
                    }
                });
                
                document.querySelectorAll('.map-option').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.map-option').forEach(el => el.classList.remove('selected'));
                        e.currentTarget.classList.add('selected');
                        selectedMap = e.currentTarget.dataset.mapId;
                        dom.buttons.nextFromMapSelect.disabled = false;
                    });
                });


                dom.buttons.createGame.addEventListener('click', () => {
                    socket.emit('createGame', { username: currentPlayer.username, map: selectedMap });
                });

                dom.buttons.joinGame.addEventListener('click', () => {
                    const gameId = dom.inputs.gameId.value.toUpperCase();
                    socket.emit('joinGame', { 
                        playerName: currentPlayer.username, 
                        gameId 
                    });
                });

                const startMultiplayerGameButton = document.getElementById('start-multiplayer-game-button');
                startMultiplayerGameButton.addEventListener('click', () => {
                    const gameId = dom.displays.gameIdDisplay.textContent;
                    socket.emit('startGame', { gameId });
                });

                dom.inputs.gameId.addEventListener('input', () => {
                    dom.buttons.joinGame.disabled = dom.inputs.gameId.value.length === 0;
                });
                
                dom.buttons.startVsAi.addEventListener('click', () => {
                    startArmyAttack();
                });


                dom.buttons.restart.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    gameState = 'mainMenu';
                    showScreen('mainMenu');
                });

                dom.buttons.specialAbility.addEventListener('click', () => players[0]?.useSpecial());
                dom.buttons.mute.addEventListener('click', () => audioManager.toggleMute());
                dom.buttons.pause.addEventListener('click', togglePause);
                dom.buttons.resume.addEventListener('click', togglePause);
                
                dom.buttons.restartFromPause.addEventListener('click', () => {
                    togglePause();
                    if (gameMode === 'survivor') {
                        startGame(players[0].charType);
                    } else if (gameMode === 'armyAttack') {
                        startArmyAttack();
                    }
                });

                dom.buttons.mainMenuFromPause.addEventListener('click', () => {
                    showScreen('confirmQuit');
                });
                dom.buttons.confirmQuitYes.addEventListener('click', () => {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    showScreen('mainMenu');
                    gameState = 'mainMenu';
                    audioManager.playMusic('menu');
                });
                dom.buttons.confirmQuitNo.addEventListener('click', () => {
                    showScreen('pause');
                });
                dom.buttons.confirmUpgrade.addEventListener('click', () => {
                    selectedUpgrades.forEach(opt => applyUpgrade(opt));
                    selectedUpgrades = [];
                    
                    updateAllUI();
                    setTimeout(() => {
                        showScreen(null);
                        gameState = 'running';
                    }, 300);
                });

                dom.buttons.armyPanelToggle.addEventListener('click', () => {
                    dom.armyPanel.classList.toggle('collapsed');
                });

                dom.buttons.upgradePanelToggle.addEventListener('click', () => {
                    dom.upgradePanel.classList.toggle('collapsed');
                });

                document.querySelectorAll('.army-unit-button').forEach(button => {
                    button.addEventListener('click', () => {
                        const unitType = button.dataset.unit;
                        const cost = armyUnitData[unitType].cost;
                        const humanPlayer = players[0];

                        if (humanPlayer && humanPlayer.wallet >= cost) {
                            humanPlayer.wallet -= cost;
                            audioManager.play('purchase');

                            const spawnX = humanPlayer.x + (Math.random() - 0.5) * 40;
                            const spawnY = humanPlayer.y + (Math.random() - 0.5) * 40;

                            entities.soldiers.push(new Soldier(spawnX, spawnY, humanPlayer, unitType));
                            updateHud();
                            updateFusionUI();
                        } else {
                            console.log("Fonds insuffisants !");
                        }
                    });
                });

                // √âcouteurs pour le nouvel √©cran de fin de partie
                document.getElementById('game-over-lobby-button').addEventListener('click', () => {
                    showScreen('multiplayerLobby'); // Retourne √† l'√©cran du lobby
                    audioManager.playMusic('menu');
                });

                document.getElementById('game-over-quit-button').addEventListener('click', () => {
                    showScreen('mainMenu'); // Retourne au menu principal
                    audioManager.playMusic('menu');
                });

                document.getElementById('game-over-spectate-button').addEventListener('click', () => {
                    const aliveBots = players.filter(p => p.hp > 0 && p.playerId !== 1);
                    if (aliveBots.length > 0) {
                        spectatedPlayer = aliveBots[0];
                        gameState = 'spectating';
                        showScreen(null); // Cache l'√©cran de d√©faite
                    }
                });


                // Gestion des entr√©es
                window.addEventListener('keydown', (e) => inputManager.handleKey(e.key, true));
                window.addEventListener('keyup', (e) => inputManager.handleKey(e.key, false));
                canvas.addEventListener('touchstart', (e) => inputManager.joystick.start(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => inputManager.joystick.move(e), { passive: false });
                canvas.addEventListener('touchend', (e) => inputManager.joystick.end(e));
                canvas.addEventListener('touchcancel', (e) => inputManager.joystick.end(e));
                canvas.addEventListener('click', handleSpectatorClick);
            }

            function updatePlayerList(players, map) {
                const playerCount = document.getElementById('player-count');
                const maxPlayers = document.getElementById('max-players');
                const playerList = document.getElementById('player-list');
                
                const mapMaxPlayers = mapData[map]?.maxPlayers || 4;

                playerCount.textContent = players.length;
                maxPlayers.textContent = mapMaxPlayers;
                playerList.innerHTML = '';
                players.forEach(player => {
                    const li = document.createElement('li');
                    li.textContent = player.name;
                    if (player.isHost) {
                        li.textContent += ' (H√¥te)';
                    }
                    playerList.appendChild(li);
                });

                // Enable start button for host if enough players
                const startButton = document.getElementById('start-multiplayer-game-button');
                const amIHost = players.find(p => p.name === currentPlayer.username)?.isHost;
                
                if (amIHost && players.length >= 2) { 
                    startButton.disabled = false;
                } else {
                    startButton.disabled = true;
                }
            }

            function updateZoom() {
                if (window.innerWidth < 768) {
                    zoomFactor = 1.5; // D√©zoomer de 50% sur mobile
                } else {
                    zoomFactor = 1.0; // Zoom par d√©faut sur bureau
                }
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                updateZoom();
            }

            function togglePause() {
                if (gameState === 'gameOver') return;

                if (gameState === 'running' || gameState === 'spectating') {
                    previousGameState = gameState;
                    gameState = 'paused';
                    showScreen('pause');
                } else if (gameState === 'paused') {
                    gameState = previousGameState;
                    hideScreen('pause');
                    lastTime = performance.now(); // Reset timer to avoid jump
                }
            }
            
            function startArmyAttack() {
                gameMode = 'armyAttack';
                resetGameState('MVX'); 
                
                showScreen(null); // Hide all menus
                dom.gameHud.classList.remove('hidden'); 
                dom.armyPanel.classList.remove('hidden');
                dom.upgradePanel.classList.remove('hidden');
                setupMultiplayerUpgrades();
                updateFusionUI();
                
                gameState = 'running';
                lastTime = performance.now();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function showCharacterSelection() {
                showScreen('characterSelection');
            }

            function startGame(charType) {
                gameMode = 'survivor';
                resetGameState(charType);
                audioManager.playMusic('game');

                showScreen(null);
                dom.gameHud.classList.remove('hidden');
                dom.buttons.specialAbility.classList.remove('hidden');
                dom.displays.passiveUpgrades.classList.remove('hidden');
                dom.displays.weaponUI.classList.remove('hidden');
                dom.armyPanel.classList.add('hidden');
                dom.upgradePanel.classList.add('hidden');
                
                gameState = 'running';
                lastTime = performance.now();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function endGame(winner = null) {
                gameState = 'gameOver';
                audioManager.playMusic('gameOver');
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            
                const humanPlayer = players[0];
                const gameOverTitle = document.getElementById('game-over-title');
                const survivorStats = document.getElementById('survivor-stats');
                const restartButton = document.getElementById('restart-button');
                const lobbyButton = document.getElementById('game-over-lobby-button');
                const spectateButton = document.getElementById('game-over-spectate-button');
                const quitButton = document.getElementById('game-over-quit-button');
                
                // Cache tous les boutons par d√©faut
                restartButton.classList.add('hidden');
                lobbyButton.classList.add('hidden');
                spectateButton.classList.add('hidden');
                quitButton.classList.add('hidden');
            
                if (gameMode === 'survivor') {
                    globalWallet += humanPlayer.wallet;
                    saveGameState();
                    
                    gameOverTitle.textContent = "LIQUIDATED!";
                    survivorStats.style.display = 'block';
                    document.getElementById('final-time').textContent = formatTime(timers.game);
                    document.getElementById('final-level').textContent = humanPlayer.level;
                    document.getElementById('final-gain').textContent = humanPlayer.wallet;
                    restartButton.classList.remove('hidden');
            
                } else if (gameMode === 'armyAttack') {
                    survivorStats.style.display = 'none'; // On cache les stats de survie

                    if (winner && winner.playerId === 1) { // Le joueur a gagn√©
                        gameOverTitle.textContent = "VICTOIRE !";
                        lobbyButton.classList.remove('hidden');
                        quitButton.classList.remove('hidden');
                    } else if (winner) { // Un bot a gagn√©
                        gameOverTitle.textContent = `D√âFAITE ! (${winner.charType} a gagn√©)`;
                        lobbyButton.classList.remove('hidden');
                        quitButton.classList.remove('hidden');
                    } else if (humanPlayer.hp <= 0) { // Le joueur a perdu (et il n'y a pas de gagnant)
                        gameOverTitle.textContent = "VOUS AVEZ PERDU !";
                        lobbyButton.classList.remove('hidden');
                        quitButton.classList.remove('hidden');

                        const alivePlayers = players.filter(p => p.hp > 0).length;
                        if (alivePlayers >= 1) { // S'il reste au moins 1 autre joueur
                            spectateButton.classList.remove('hidden');
                        }
                    }
                }
                
                dom.gameHud.classList.add('hidden');
                dom.buttons.specialAbility.classList.add('hidden');
                dom.displays.passiveUpgrades.classList.add('hidden');
                dom.displays.weaponUI.classList.add('hidden');
                dom.armyPanel.classList.add('hidden');
                showScreen('gameOverScreen');
            }

            function resetGameState(charType) {
                players = [];
                const humanPlayer = new Player(charType, 1);
                players.push(humanPlayer);

                if (gameMode === 'survivor') {
                    humanPlayer.x = WORLD_WIDTH / 2;
                    humanPlayer.y = WORLD_HEIGHT / 2;
                    humanPlayer.addWeapon(weaponList.buy.init(humanPlayer));
                    updateAllUI(); // Mettre √† jour l'UI apr√®s la cr√©ation du joueur et de son arme
                } else if (gameMode === 'armyAttack') {
                    // Reset multiplayer upgrades for the new game
                    Object.keys(multiplayerUpgrades).forEach(key => {
                        multiplayerUpgrades[key].level = 0;
                    });

                    if (selectedMap === 'quadrant_4p') {
                        const positions = [
                            { x: WORLD_WIDTH * 0.25, y: WORLD_HEIGHT * 0.25 }, // P1
                            { x: WORLD_WIDTH * 0.75, y: WORLD_HEIGHT * 0.25 }, // P2
                            { x: WORLD_WIDTH * 0.25, y: WORLD_HEIGHT * 0.75 }, // P3
                            { x: WORLD_WIDTH * 0.75, y: WORLD_HEIGHT * 0.75 }  // P4
                        ];
                        
                        players[0].x = positions[0].x;
                        players[0].y = positions[0].y;
                        players[0].addWeapon(weaponList.buy.init(players[0]));

                        const botChars = ['AVAX', 'SOL', 'ETH'];
                        for (let i = 0; i < 3; i++) {
                            const bot = new BotPlayer(botChars[i], i + 2);
                            bot.x = positions[i + 1].x;
                            bot.y = positions[i + 1].y;
                            bot.addWeapon(weaponList.buy.init(bot));
                            players.push(bot);
                        }
                    } else if (selectedMap === 'vertical_2p') {
                          const positions = [
                            { x: WORLD_WIDTH * 0.5, y: WORLD_HEIGHT * 0.25 }, // P1
                            { x: WORLD_WIDTH * 0.5, y: WORLD_HEIGHT * 0.75 }, // P2
                        ];
                        players[0].x = positions[0].x;
                        players[0].y = positions[0].y;
                        players[0].addWeapon(weaponList.buy.init(players[0]));
                        const bot = new BotPlayer('AVAX', 2);
                        bot.x = positions[1].x;
                        bot.y = positions[1].y;
                        bot.addWeapon(weaponList.buy.init(bot));
                        players.push(bot);
                    }
                }
                
                Object.keys(entities).forEach(key => entities[key] = []);
                Object.keys(timers).forEach(key => timers[key] = 0);
                armyAttackTimers = { wave: 0, waveCount: 0 };
                
                activeMiniBoss = null;
            }

                        function gameLoop(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const dt = timestamp - lastTime;
                lastTime = timestamp;

                // 1. Mettre √† jour la logique (mouvements, collisions, etc.)
                if (gameState === 'running' || gameState === 'spectating') {
                    if (gameMode === 'survivor') {
                        updateSurvivor(dt);
                    } else if (gameMode === 'armyAttack') {
                        updateArmyAttack(dt);
                    }
                }

                // 2. Dessiner l'√©tat actuel
                draw();

                // 3. Demander la prochaine frame
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function update(dt) {
                if (gameMode === 'survivor') {
                    updateSurvivor(dt);
                } else if (gameMode === 'armyAttack') {
                    updateArmyAttack(dt);
                }
                handleCollisions();
            }

            function draw() {
                // Effacer le canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();

                // G√©rer la cam√©ra si on est en jeu ou en spectateur
                if (gameState === 'running' || gameState === 'spectating') {
                    updateCamera();
                    ctx.translate(-camera.x, -camera.y);
                }

                // Dessiner le monde et les entit√©s
                drawWorldBackground();
                Object.values(entities).flat().forEach(e => e.draw());
                players.forEach(p => p.draw());

                ctx.restore();

                // Dessiner l'UI par-dessus tout
                if (gameState === 'running' || gameState === 'spectating') {
                    updateHud();
                    if (gameMode === 'armyAttack') drawMinimap();
                }
            }

            function updateArmyAttack(dt) {
                timers.game += dt / 1000;
                armyAttackTimers.wave += dt;

                if (armyAttackTimers.wave > TOWER_WAVE_INTERVAL) {
                    spawnArmyWave();
                    armyAttackTimers.wave = 0; 
                }

                players.forEach(p => p.update(dt));
                Object.values(entities).flat().forEach(e => e.update(dt));
                updatePentagrams(dt);

                updateCamera();
                handleCollisions();

                Object.keys(entities).forEach(key => {
                    entities[key] = entities[key].filter(e => e.lifespan === undefined || e.lifespan > 0);
                });
                entities.enemies = entities.enemies.filter(e => e.hp > 0);

                updateHud();
                updateFusionUI(); // Mettre √† jour les options de fusion
                updatePentagramUI();

                // V√©rification de la d√©faite du joueur humain
                const humanPlayer = players[0];
                if (humanPlayer && humanPlayer.hp <= 0 && gameState === 'running') {
                    endGame(null); // Appelle la fin de partie si le joueur est mort
                    return; // Arr√™te la fonction update pour cette frame
                }

                // Check for winner
                const alivePlayers = players.filter(p => p.hp > 0);
                if (alivePlayers.length <= 1 && gameState === 'running') {
                    endGame(alivePlayers[0]);
                }
            }

            function drawArmyAttackElements() {
                ctx.fillStyle = 'rgb(17, 34, 64)';
                if (selectedMap === 'quadrant_4p') {
                    ctx.fillRect(WORLD_WIDTH / 2 - 10, 0, 20, WORLD_HEIGHT);
                    ctx.fillRect(0, WORLD_HEIGHT / 2 - 10, WORLD_WIDTH, 20);
                } else if (selectedMap === 'vertical_2p') {
                    ctx.fillRect(0, WORLD_HEIGHT / 2 - 10, WORLD_WIDTH, 20);
                }
            }

            function updateSurvivor(dt) {
                const humanPlayer = players[0];
                timers.game += dt / 1000;
                timers.enemySpawn += dt;
                timers.magnetSpawn += dt;
                timers.healthSpawn += dt;
                
                if (timers.enemySpawn > ENEMY_BASE_SPAWN_RATE) {
                    spawnEnemyWave();
                    timers.enemySpawn = 0;
                }
                if (timers.magnetSpawn > MAGNET_SPAWN_RATE) {
                    entities.magnets.push(new Magnet(camera.x + Math.random() * canvas.width, camera.y + Math.random() * canvas.height));
                    timers.magnetSpawn = 0;
                }
                if (timers.healthSpawn > HEALTH_SPAWN_RATE) {
                    entities.healthPickups.push(new HealthPickup(camera.x + Math.random() * canvas.width, camera.y + Math.random() * canvas.height));
                    timers.healthSpawn = 0;
                }

                humanPlayer.update(dt);
                updateCamera();
                Object.values(entities).flat().forEach(e => e.update(dt));

                handleCollisions();
                
                Object.keys(entities).forEach(key => {
                    entities[key] = entities[key].filter(e => e.lifespan === undefined || e.lifespan > 0);
                });
                entities.enemies = entities.enemies.filter(e => e.hp > 0);

                updateHud();
            }

            function updateCamera() {
                const target = gameState === 'spectating' ? spectatedPlayer : players[0];
                // On v√©rifie que la cible existe avant de continuer
                if (!target) return;

                const viewWidth = canvas.width * zoomFactor;
                const viewHeight = canvas.height * zoomFactor;

                camera.x = target.x - viewWidth / 2;
                camera.y = target.y - viewHeight / 2;
                
                const bounds = getQuadrantBoundaries(target.playerId);
                camera.x = Math.max(bounds.minX, Math.min(bounds.maxX - viewWidth, camera.x));
                camera.y = Math.max(bounds.minY, Math.min(bounds.maxY - viewHeight, camera.y));
            }

            function handleSpectatorClick() {
                if (gameState !== 'spectating') return;

                const aliveBots = players.filter(p => p.hp > 0 && p.playerId !== 1);
                if (aliveBots.length === 0) {
                    spectatedPlayer = null;
                    return;
                }

                const currentIndex = aliveBots.findIndex(p => p === spectatedPlayer);
                const nextIndex = (currentIndex + 1) % aliveBots.length;
                spectatedPlayer = aliveBots[nextIndex];
            }

            function drawMinimap() {
                if (players.length === 0) return;

                const minimap = dom.displays.minimapCanvas;
                const minimapCtx = minimap.getContext('2d');
                const mapWidth = minimap.width;
                const mapHeight = minimap.height;

                minimapCtx.fillStyle = 'rgba(17, 34, 64, 0.8)';
                minimapCtx.fillRect(0, 0, mapWidth, mapHeight);

                minimapCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
                minimapCtx.lineWidth = 1;
                minimapCtx.beginPath();
                if (gameMode === 'armyAttack') {
                    if (selectedMap === 'quadrant_4p') {
                        minimapCtx.moveTo(mapWidth / 2, 0);
                        minimapCtx.lineTo(mapWidth / 2, mapHeight);
                    }
                    minimapCtx.moveTo(0, mapHeight / 2);
                    minimapCtx.lineTo(mapWidth, mapHeight / 2);
                    minimapCtx.stroke();
                }

                players.forEach(p => {
                    if (p.hp > 0) {
                        const playerX = (p.x / WORLD_WIDTH) * mapWidth;
                        const playerY = (p.y / WORLD_HEIGHT) * mapHeight;
                        minimapCtx.fillStyle = p.playerId === 1 ? 'white' : p.color;
                        minimapCtx.beginPath();
                        minimapCtx.arc(playerX, playerY, 3, 0, Math.PI * 2);
                        minimapCtx.fill();
                    }
                });

                if (gameMode === 'survivor') {
                    entities.bonusUpgrades.forEach(bonus => {
                        const bonusX = (bonus.x / WORLD_WIDTH) * mapWidth;
                        const bonusY = (bonus.y / WORLD_HEIGHT) * mapHeight;
                        minimapCtx.fillStyle = 'white';
                        minimapCtx.font = 'bold 12px "Roboto Mono"';
                        minimapCtx.textAlign = 'center';
                        minimapCtx.textBaseline = 'middle';
                        minimapCtx.fillText('+', bonusX, bonusY);
                    });
                } else if (gameMode === 'armyAttack') {
                    entities.enemies.forEach(enemy => {
                        const enemyX = (enemy.x / WORLD_WIDTH) * mapWidth;
                        const enemyY = (enemy.y / WORLD_HEIGHT) * mapHeight;
                        minimapCtx.fillStyle = enemy.color;
                        minimapCtx.fillRect(enemyX - 1, enemyY - 1, 2, 2);
                    });
                }
            }

            function drawWorldBackground() {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 10;
                ctx.strokeRect(5, 5, WORLD_WIDTH - 10, WORLD_HEIGHT - 10);
                
                const gridSize = 100;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                for(let x = 0; x < WORLD_WIDTH; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, WORLD_HEIGHT);
                    ctx.stroke();
                }
                 for(let y = 0; y < WORLD_HEIGHT; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(WORLD_WIDTH, y);
                    ctx.stroke();
                }
            }
            
            function handleCollisions() {
                const humanPlayer = players[0];
                if (!humanPlayer) return;

                // Projectile vs Enemy
                for (let i = entities.projectiles.length - 1; i >= 0; i--) {
                    const p = entities.projectiles[i];
                    if (p.lifespan <= 0 || p instanceof LaserBeam) continue;

                    for (let j = entities.enemies.length - 1; j >= 0; j--) {
                        const e = entities.enemies[j];
                        if (e.hp <= 0) continue;

                        if (Math.hypot(p.x - e.x, p.y - e.y) < p.radius + e.radius) {
                            e.takeDamage(p.damage);

                            if (p.onHit) {
                                p.onHit();
                                break; 
                            }

                            if (p.pierce > 0) {
                                p.pierce--;
                            } else {
                                p.lifespan = 0;
                                break; 
                            }
                        }
                    }
                }
                
                // Player vs Enemy
                players.forEach(p => {
                    if (p.hp > 0) {
                        entities.enemies.forEach(e => {
                            if (Math.hypot(p.x - e.x, p.y - e.y) < p.radius + e.radius) {
                                p.takeDamage(e.damage);
                                const angle = Math.atan2(e.y - p.y, e.x - p.x);
                                e.x += Math.cos(angle) * 5;
                                e.y += Math.sin(angle) * 5;
                            }
                        });
                    }
                });

                // Enemy vs Boss
                if (activeMiniBoss) {
                    entities.enemies.forEach(e => {
                        if (e !== activeMiniBoss && Math.hypot(activeMiniBoss.x - e.x, activeMiniBoss.y - e.y) < activeMiniBoss.radius + e.radius) {
                            const angle = Math.atan2(e.y - activeMiniBoss.y, e.x - activeMiniBoss.x);
                            e.x += Math.cos(angle) * 2;
                            e.y += Math.sin(angle) * 2;
                        }
                    });
                }
                
                // Player vs Pickups (seulement le joueur humain)
                for (let i = entities.xpOrbs.length - 1; i >= 0; i--) {
                    const orb = entities.xpOrbs[i];
                    if (Math.hypot(humanPlayer.x - orb.x, humanPlayer.y - orb.y) < humanPlayer.pickupRadius) {
                        audioManager.play('collect');
                        humanPlayer.gainXp(orb.value);
                        entities.xpOrbs.splice(i, 1);
                    }
                }
                
                for (let i = entities.magnets.length - 1; i >= 0; i--) {
                    const magnet = entities.magnets[i];
                    if (Math.hypot(humanPlayer.x - magnet.x, humanPlayer.y - magnet.y) < humanPlayer.radius + magnet.radius) {
                        entities.xpOrbs.forEach(orb => orb.isAttracted = true);
                        entities.magnets.splice(i, 1);
                    }
                }

                for (let i = entities.healthPickups.length - 1; i >= 0; i--) {
                    const pickup = entities.healthPickups[i];
                    if (Math.hypot(humanPlayer.x - pickup.x, humanPlayer.y - pickup.y) < humanPlayer.radius + pickup.radius) {
                        humanPlayer.hp = Math.min(humanPlayer.maxHp, humanPlayer.hp + pickup.healAmount);
                        audioManager.play('healthPickup');
                        createFloatingText(`+${pickup.healAmount} HP`, humanPlayer.x, humanPlayer.y, 'var(--health-color)');
                        entities.healthPickups.splice(i, 1);
                    }
                }

                for (let i = entities.bonusUpgrades.length - 1; i >= 0; i--) {
                    const bonus = entities.bonusUpgrades[i];
                    if (Math.hypot(humanPlayer.x - bonus.x, humanPlayer.y - bonus.y) < humanPlayer.radius + bonus.radius) {
                        audioManager.play('healthPickup'); // Reuse a nice sound
                        humanPlayer.extraUpgradeCharges++;
                        createFloatingText('+1 Am√©lioration!', humanPlayer.x, humanPlayer.y, 'gold');
                        entities.bonusUpgrades.splice(i, 1);
                    }
                }
            }

            function showScreen(screenId) {
                Object.values(dom.screens).forEach(screen => screen.classList.remove('active'));
                if (screenId && dom.screens[screenId]) {
                    dom.screens[screenId].classList.add('active');
                }
            }
            
            function updateHud() {
                const humanPlayer = players[0];
                if (!humanPlayer) {
                    dom.gameHud.classList.add('hidden');
                    return;
                }
                dom.gameHud.classList.remove('hidden');

                dom.displays.playerLevel.textContent = humanPlayer.level;
                dom.displays.playerWallet.textContent = humanPlayer.wallet;
                dom.displays.topHealthBarFill.style.width = `${(humanPlayer.hp / humanPlayer.maxHp) * 100}%`;
                dom.displays.topHealthBarText.textContent = `${Math.ceil(humanPlayer.hp)} / ${Math.ceil(humanPlayer.maxHp)}`;
                dom.displays.gameTimer.textContent = formatTime(timers.game);
                dom.displays.xpBar.style.width = `${Math.min(100, (humanPlayer.xp / humanPlayer.xpToNextLevel) * 100)}%`;
                dom.displays.xpBarText.textContent = `${Math.floor(humanPlayer.xp)} / ${humanPlayer.xpToNextLevel}`;

                if (gameMode === 'survivor' && entities.bonusUpgrades.length > 0) {
                    const bonus = entities.bonusUpgrades[0];
                    dom.displays.bonusTimer.textContent = `+1: ${Math.ceil(bonus.lifespan / 1000)}s`;
                    dom.displays.bonusTimer.classList.remove('hidden');
                } else {
                    dom.displays.bonusTimer.classList.add('hidden');
                }
            }

            function displayShop() {
                dom.displays.shopWallet.innerHTML = `${globalWallet.toLocaleString()} $<span class="mvx-logo-inline">X</span>`;
                const container = dom.displays.shopItemsContainer;
                container.innerHTML = '';

                Object.keys(shopData).forEach(key => {
                    const item = shopData[key];
                    const currentLevel = permanentUpgrades[key];
                    const maxLevel = item.levels.length;
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'shop-item';

                    let actionHTML;
                    if (currentLevel >= maxLevel) {
                        actionHTML = `<div class="shop-item-action"><span>Niveau MAX</span></div>`;
                    } else {
                        const nextLevelInfo = item.levels[currentLevel];
                        const canAfford = globalWallet >= nextLevelInfo.cost;
                        actionHTML = `
                            <div class="shop-item-action">
                                <button onclick="purchaseUpgrade('${key}')" ${canAfford ? '' : 'disabled'}>
                                    ${nextLevelInfo.cost.toLocaleString()} $<span class="mvx-logo-inline">X</span>
                                </button>
                            </div>
                        `;
                    }

                    itemDiv.innerHTML = `
                        <div class="shop-item-info">
                            <strong>${item.icon} ${item.name}</strong>
                            <p>Niveau: ${currentLevel} / ${maxLevel}</p>
                            ${currentLevel < maxLevel ? `<p>Prochain: +${item.levels[currentLevel].bonus * 100}%</p>` : '<p>Bonus max atteint !</p>'}
                        </div>
                        ${actionHTML}
                    `;
                    container.appendChild(itemDiv);
                });
            }

            window.purchaseUpgrade = function(key) {
                const item = shopData[key];
                const currentLevel = permanentUpgrades[key];
                const maxLevel = item.levels.length;

                if (currentLevel < maxLevel) {
                    const nextLevelInfo = item.levels[currentLevel];
                    if (globalWallet >= nextLevelInfo.cost) {
                        audioManager.play('purchase');
                        globalWallet -= nextLevelInfo.cost;
                        permanentUpgrades[key]++;
                        saveGameState();
                        displayShop(); // Refresh the shop UI
                    }
                }
            }


            function setupCharacterSelection() {
                const charSelectContainer = dom.screens.characterSelection.querySelector('.char-grid');
                if (!charSelectContainer) return;

                // Cette fonction est maintenant appel√©e une seule fois pour attacher les √©couteurs.
                // Une autre fonction mettra √† jour l'√©tat visuel si n√©cessaire.
                if (!charSelectContainer.dataset.initialized) {
                    charSelectContainer.querySelectorAll('.char-select-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const charType = btn.dataset.char;
                            const isUnlocked = unlockedCharacters.includes(charType);

                            if (isUnlocked) {
                                gameMode = 'survivor'; // D√©finir le mode de jeu ICI
                                startGame(charType);
                            } else {
                                const cost = characterData[charType].cost;
                                if (globalWallet >= cost) {
                                    globalWallet -= cost;
                                    unlockedCharacters.push(charType);
                                    saveGameState();
                                    updateWalletDisplay();
                                    updateCharacterSelectionUI(); // Mettre √† jour seulement l'UI
                                } else {
                                    createFloatingText("Fonds insuffisants!", window.innerWidth / 2, window.innerHeight / 2, 'orange', 2000);
                                }
                            }
                        });
                    });
                    charSelectContainer.dataset.initialized = 'true';
                }
                // Mettre √† jour l'UI √† chaque affichage
                updateCharacterSelectionUI();
            }

            function updateCharacterSelectionUI() {
                const charSelectContainer = dom.screens.characterSelection.querySelector('.char-grid');
                if (!charSelectContainer) return;

                charSelectContainer.querySelectorAll('.char-select-btn').forEach(btn => {
                    const charType = btn.dataset.char;
                    const isUnlocked = unlockedCharacters.includes(charType);
                    const costEl = btn.querySelector('.char-cost');

                    if (isUnlocked) {
                        btn.classList.remove('locked');
                        if(costEl) costEl.style.display = 'none';
                    } else {
                        btn.classList.add('locked');
                        if(costEl) {
                            costEl.style.display = 'block';
                            costEl.innerHTML = `<span class="wallet-icon"></span>${characterData[charType].cost}`;
                        }
                    }
                });
            }

            function applyUpgrade(option) {
                const humanPlayer = players[0];
                if (option.type === 'upgradeWeapon') {
                    option.weapon.upgrade();
                } else if (option.type === 'newWeapon') {
                    humanPlayer.addWeapon(weaponList[option.weaponKey].init(humanPlayer));
                } else if (option.type === 'passive') {
                    passiveUpgrades[option.key].apply(humanPlayer, option.bonus);
                    humanPlayer.acquiredPassives.push({ key: option.key, level: option.level, bonus: option.bonus });
                }
            }

            function displayLevelUpOptions() {
                const humanPlayer = players[0];
                const optionsContainer = dom.displays.levelUpOptions;
                optionsContainer.innerHTML = '';
                dom.buttons.confirmUpgrade.classList.add('hidden');
                selectedUpgrades = [];
                
                // --- Logique de g√©n√©ration des options (commune aux deux cas) ---
                const weaponUpgradeOptions = humanPlayer.weapons
                    .filter(w => w.level < w.maxLevel)
                    .map(w => ({ type: 'upgradeWeapon', weapon: w, name: weaponList[w.key].name, text: w.getUpgradeDescription(), level: w.level + 1 }));

                const newWeaponOptions = Object.keys(weaponList)
                    .filter(key => !humanPlayer.weapons.some(w => w.key === key))
                    .map(key => ({ type: 'newWeapon', weaponKey: key, name: weaponList[key].name, text: weaponList[key].description, level: 1 }));

                const passivePool = [];
                Object.keys(passiveUpgrades).forEach(key => {
                    const upgradeInfo = passiveUpgrades[key];
                    upgradeInfo.levels.forEach(levelInfo => {
                        const option = {
                            type: 'passive',
                            key: key,
                            ...levelInfo,
                            name: `${upgradeInfo.name} (Niv. ${levelInfo.level})`,
                            text: `Ajoute un bonus de +${(levelInfo.bonus * 100).toFixed(0)}%`
                        };
                        for (let i = 0; i < levelInfo.weight; i++) {
                            passivePool.push(option);
                        }
                    });
                });

                let availableOptions = [...weaponUpgradeOptions, ...newWeaponOptions];
                if(passivePool.length > 0) {
                    for (let i = passivePool.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [passivePool[i], passivePool[j]] = [passivePool[j], passivePool[i]];
                    }
                    const uniquePassiveOptions = [];
                    for(const option of passivePool) {
                        if(!uniquePassiveOptions.some(o => o.key === option.key && o.level === option.level)) {
                            uniquePassiveOptions.push(option);
                        }
                        if(uniquePassiveOptions.length >= 4) break; // On en prend un peu plus pour assurer 3 uniques
                    }
                    availableOptions.push(...uniquePassiveOptions);
                }

                availableOptions.sort(() => 0.5 - Math.random());
                const choiceCount = humanPlayer.level >= 40 ? 5 : 4;
                const chosenOptions = availableOptions.slice(0, choiceCount);
                
                // --- Logique de Bonus de Boss ---
                if (humanPlayer.isBonusLevelUp) {
                    dom.displays.levelUpTitle.textContent = "BOSS VAINCU - BONUS !";
                    dom.displays.levelUpSubtitle.textContent = `Vous obtenez les ${chosenOptions.length} am√©liorations suivantes gratuitement !`;

                    if (chosenOptions.length === 0) {
                        optionsContainer.innerHTML = `<p>Toutes les am√©liorations sont au maximum ! +500 $<span class="mvx-logo-inline">X</span> en compensation !</p>`;
                        humanPlayer.wallet += 500;
                    } else {
                        chosenOptions.forEach(opt => {
                            applyUpgrade(opt);
                            const optionDiv = document.createElement('div');
                            optionDiv.className = 'level-up-option disabled'; // Gris√© car d√©j√† appliqu√©
                            optionDiv.dataset.level = Math.min(opt.level, 5);
                            optionDiv.innerHTML = `<strong>${opt.name}</strong><p>${opt.text}</p>`;
                            optionsContainer.appendChild(optionDiv);
                        });
                    }

                    const continueButton = document.createElement('button');
                    continueButton.className = 'action-button';
                    continueButton.textContent = 'Continuer';
                    continueButton.style.marginTop = '20px';
                    continueButton.onclick = () => {
                        updateAllUI();
                        showScreen(null);
                        gameState = 'running';
                    };
                    optionsContainer.appendChild(continueButton);

                    humanPlayer.isBonusLevelUp = false; // R√©initialiser le flag
                    showScreen('levelUp');
                    return;
                }
                
                // --- Logique normale de Level Up ---
                if (humanPlayer.extraUpgradeCharges > 0) {
                    humanPlayer.upgradesToPick = 2;
                    humanPlayer.extraUpgradeCharges--;
                    dom.displays.levelUpSubtitle.textContent = `Vous pouvez prendre DEUX am√©liorations :`;
                } else {
                    humanPlayer.upgradesToPick = 1;
                    dom.displays.levelUpSubtitle.textContent = `Choisissez UNE seule am√©lioration :`;
                }

                if (chosenOptions.length === 0) {
                    createFloatingText("Maxed Out! +100$", humanPlayer.x, humanPlayer.y, 'gold');
                    humanPlayer.wallet += 100;
                    gameState = 'running';
                    return;
                }

                chosenOptions.forEach(opt => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'level-up-option';
                    optionDiv.dataset.level = Math.min(opt.level, 5);
                    optionDiv.innerHTML = `<strong>${opt.name}</strong><p>${opt.text}</p>`;
                    optionDiv.onclick = () => selectLevelUpOption(opt, optionDiv);
                    optionsContainer.appendChild(optionDiv);
                });

                showScreen('levelUp');
            }

            function selectLevelUpOption(option, optionDiv) {
                const humanPlayer = players[0];
                if (selectedUpgrades.includes(option)) {
                    // Deselect
                    selectedUpgrades = selectedUpgrades.filter(item => item !== option);
                    optionDiv.classList.remove('selected');
                } else {
                    // Select
                    if (selectedUpgrades.length < humanPlayer.upgradesToPick) {
                        selectedUpgrades.push(option);
                        optionDiv.classList.add('selected');
                    }
                }

                if (selectedUpgrades.length === humanPlayer.upgradesToPick) {
                    dom.buttons.confirmUpgrade.classList.remove('hidden');
                } else {
                    dom.buttons.confirmUpgrade.classList.add('hidden');
                }
            }
            
            function updatePassiveUpgradesUI() {
                 const humanPlayer = players[0];
                 if (!humanPlayer) return;
                 dom.displays.passiveUpgrades.innerHTML = '';

                const passiveDisplayData = {
                    damage: { value: humanPlayer.globalDamageMultiplier, icon: passiveUpgrades.damage.icon, name: "Puissance de Feu" },
                    range: { value: humanPlayer.projectileLifespanBonus, icon: passiveUpgrades.range.icon, name: "Long HODL" },
                    xpGain: { value: humanPlayer.xpGainBonus, icon: passiveUpgrades.xpGain.icon, name: "Airdrop d'XP" }
                };

                Object.keys(passiveDisplayData).forEach(key => {
                    const data = passiveDisplayData[key];
                    const totalBonus = data.value;
                    const baseValue = 1.0;

                    if (Math.abs(totalBonus - baseValue) > 0.001) {
                        const percentage = `+${Math.round((totalBonus - 1) * 100)}%`;
                        
                        const div = document.createElement('div');
                        div.className = 'passive-upgrade-icon';
                        div.innerHTML = `${data.icon} ${percentage}`;
                        div.title = `${data.name} (${percentage})`;
                        dom.displays.passiveUpgrades.appendChild(div);
                    }
                });
            }

            function updateWeaponDisplay() {
                const container = dom.displays.weaponUI;
                if (!container) return;
                container.innerHTML = '';
                const humanPlayer = players[0];
                if (!humanPlayer) return;

                humanPlayer.weapons.forEach(weapon => {
                    const weaponInfo = weaponList[weapon.key];
                    if (weaponInfo) {
                        const icon = document.createElement('div');
                        icon.className = 'weapon-icon';
                        icon.textContent = `${weaponInfo.icon} ${weapon.level}`;
                        container.appendChild(icon);
                    }
                });
            }

            function updateAllUI() {
                updateHud();

                updateWeaponDisplay();
                updatePassiveUpgradesUI();
            }

            // --- LOGIQUE DE SPAWN ---
            function getSpawnPosition() {
                const humanPlayer = players[0];
                if (!humanPlayer) return { x: 0, y: 0 };
                const angle = Math.random() * Math.PI * 2;
                const spawnDist = Math.max(canvas.width, canvas.height) / 2 * zoomFactor + 50;
                const x = humanPlayer.x + Math.cos(angle) * spawnDist;
                const y = humanPlayer.y + Math.sin(angle) * spawnDist;
                return { x, y };
            };

            function spawnEnemyWave() {
                const humanPlayer = players[0];
                if (!humanPlayer) return;
                const currentTier = Math.min(Math.floor((humanPlayer.level - 1) / 10), bossProgression.length - 1);
                
                if (humanPlayer.level % 5 === 0 && humanPlayer.level > humanPlayer.lastBossSpawnLevel && !activeMiniBoss) {
                    const isDemiBoss = humanPlayer.level % 10 !== 0;
                    const { x, y } = getSpawnPosition();
                    
                    activeMiniBoss = new MiniBoss(currentTier, x, y, 1, isDemiBoss);
                    entities.enemies.push(activeMiniBoss);
                    humanPlayer.lastBossSpawnLevel = humanPlayer.level;
                    audioManager.playMusic(isDemiBoss ? 'miniBoss' : 'mainBoss');
                }
                
                const baseCount = 2;
                const levelInTier = (humanPlayer.level - 1) % 10;
                let enemyCount = Math.floor(baseCount + Math.pow(1.6, levelInTier));
                enemyCount = Math.min(enemyCount, 250);
                
                const tankSpawnChance = 0.02;

                for (let i = 0; i < enemyCount; i++) {
                    const { x, y } = getSpawnPosition();
                    const quadrant = 1; // Solo mode is always quadrant 1

                    if (Math.random() < tankSpawnChance) {
                        entities.enemies.push(new TankEnemy(currentTier, x, y, quadrant));
                    } else {
                        entities.enemies.push(new Enemy(currentTier, x, y, quadrant));
                    }
                }
            }


            function spawnArmyWave() {
                if (players.length === 0) return;

                const waveSize = 2 + armyAttackTimers.waveCount;
                const portalRadius = 100;
                
                let portalPositions = [];
                if (selectedMap === 'quadrant_4p') {
                    portalPositions = [
                        { x: portalRadius, y: portalRadius, quadrant: 1 },
                        { x: WORLD_WIDTH - portalRadius, y: portalRadius, quadrant: 2 },
                        { x: portalRadius, y: WORLD_HEIGHT - portalRadius, quadrant: 3 },
                        { x: WORLD_WIDTH - portalRadius, y: WORLD_HEIGHT - portalRadius, quadrant: 4 }
                    ];
                } else if (selectedMap === 'vertical_2p') {
                    portalPositions = [
                        { x: WORLD_WIDTH * 0.5, y: portalRadius, quadrant: 1 },
                        { x: WORLD_WIDTH * 0.5, y: WORLD_HEIGHT - portalRadius, quadrant: 2 }
                    ];
                }


                portalPositions.forEach(portal => {
                    for (let i = 0; i < waveSize; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const x = portal.x + Math.cos(angle) * portalRadius;
                        const y = portal.y + Math.sin(angle) * portalRadius;
                        entities.enemies.push(new Enemy(0, x, y, portal.quadrant));
                    }
                });
                
                armyAttackTimers.waveCount++;
            }

            function spawnBonusUpgrade() {
                let x, y;
                const spawnMargin = 100;
                if (Math.random() < 0.5) {
                    x = camera.x + (Math.random() < 0.5 ? -spawnMargin : canvas.width + spawnMargin);
                    y = camera.y + Math.random() * (canvas.height + spawnMargin * 2) - spawnMargin;
                } else {
                    x = camera.x + Math.random() * (canvas.width + spawnMargin * 2) - spawnMargin;
                    y = camera.y + (Math.random() < 0.5 ? -spawnMargin : canvas.height + spawnMargin);
                }
                entities.bonusUpgrades.push(new BonusUpgrade(x, y));
            }
            
            // --- FONCTIONS UTILITAIRES ---
            function getQuadrantBoundaries(playerId) {
                const wallThickness = 10;
                if (gameMode === 'survivor') {
                    return { minX: 0, maxX: WORLD_WIDTH, minY: 0, maxY: WORLD_HEIGHT };
                }
                if (selectedMap === 'quadrant_4p') {
                    switch(playerId) {
                        case 1: // Haut-gauche
                            return { minX: 0, maxX: WORLD_WIDTH / 2 - wallThickness, minY: 0, maxY: WORLD_HEIGHT / 2 - wallThickness };
                        case 2: // Haut-droite
                            return { minX: WORLD_WIDTH / 2 + wallThickness, maxX: WORLD_WIDTH, minY: 0, maxY: WORLD_HEIGHT / 2 - wallThickness };
                        case 3: // Bas-gauche
                            return { minX: 0, maxX: WORLD_WIDTH / 2 - wallThickness, minY: WORLD_HEIGHT / 2 + wallThickness, maxY: WORLD_HEIGHT };
                        case 4: // Bas-droite
                            return { minX: WORLD_WIDTH / 2 + wallThickness, maxX: WORLD_WIDTH, minY: WORLD_HEIGHT / 2 + wallThickness, maxY: WORLD_HEIGHT };
                    }
                } else if (selectedMap === 'vertical_2p') {
                     switch(playerId) {
                        case 1: // Haut
                            return { minX: 0, maxX: WORLD_WIDTH, minY: 0, maxY: WORLD_HEIGHT / 2 - wallThickness };
                        case 2: // Bas
                            return { minX: 0, maxX: WORLD_WIDTH, minY: WORLD_HEIGHT / 2 + wallThickness, maxY: WORLD_HEIGHT };
                    }
                }
                return { minX: 0, maxX: WORLD_WIDTH, minY: 0, maxY: WORLD_HEIGHT }; // Fallback
            }

            function formatTime(s) {
                const minutes = Math.floor(s / 60).toString().padStart(2, '0');
                const seconds = Math.floor(s % 60).toString().padStart(2, '0');
                return `${minutes}:${seconds}`;
            }

            function createFloatingText(text, x, y, color) {
                const colorValue = color.startsWith('var') ? getComputedStyle(document.documentElement).getPropertyValue(color.replace(/var\(|\)/g, '')) : color;
                entities.floatingTexts.push(new FloatingText(text, x, y, colorValue));
            }
            
            // --- GESTIONNAIRE D'ENTR√âES ---
            const inputManager = {
                keys: { up: false, down: false, left: false, right: false },
                handleKey(key, isDown) {
                    switch (key.toLowerCase()) {
                        case 'arrowup': case 'z': this.keys.up = isDown; break;
                        case 'arrowdown': case 's': this.keys.down = isDown; break;
                        case 'arrowleft': case 'q': this.keys.left = isDown; break;
                        case 'arrowright': case 'd': this.keys.right = isDown; break;
                        case 'a': 
                            if(isDown) players[0]?.useSpecial();
                            break;
                        case 'escape':
                            if(isDown && (gameState === 'running' || gameState === 'paused')) togglePause();
                            break;
                    }
                },
                joystick: {
                    container: document.getElementById('joystick-container'),
                    handle: document.getElementById('joystick-handle'),
                    active: false, touchId: null, radius: 60,
                    inputX: 0, inputY: 0, centerX: 0, centerY: 0,
                    start(e) {
                        e.preventDefault();
                        if (this.touchId !== null) return;
                        const touch = e.changedTouches[0];
                        this.touchId = touch.identifier;
                        this.active = true;
                        this.container.style.display = 'block';
                        this.centerX = touch.clientX;
                        this.centerY = touch.clientY;
                        this.container.style.left = `${this.centerX - this.radius}px`;
                        this.container.style.top = `${this.centerY - this.radius}px`;
                    },
                    move(e) {
                        e.preventDefault();
                        if (!this.active) return;
                        const touch = Array.from(e.changedTouches).find(t => t.identifier === this.touchId);
                        if (!touch) return;
                        
                        const dx = touch.clientX - this.centerX;
                        const dy = touch.clientY - this.centerY;
                        const distance = Math.hypot(dx, dy);
                        const angle = Math.atan2(dy, dx);
                        
                        const clampedDistance = Math.min(distance, this.radius);
                        this.inputX = Math.cos(angle) * (clampedDistance / this.radius);
                        this.inputY = Math.sin(angle) * (clampedDistance / this.radius);
                        
                        this.handle.style.transform = `translate(-50%, -50%) translate(${this.inputX * this.radius}px, ${this.inputY * this.radius}px)`;
                    },
                    end(e) {
                        if (Array.from(e.changedTouches).some(t => t.identifier === this.touchId)) {
                            this.active = false; this.touchId = null;
                            this.inputX = 0; this.inputY = 0;
                            this.handle.style.transform = 'translate(-50%, -50%)';
                            this.container.style.display = 'none';
                        }
                    }
                }
            };

            // --- DONN√âES DE CONFIGURATION STATIQUES ---
            const characterData = {
                'MVX': { name: 'MVX', colorVar: '--mvx-color', symbol: 'X', cooldown: 22000, special: (p) => { entities.projectiles.push(new Rocket(p.x, p.y, p)); }, specialName: "Roquette HODL" },
                'AVAX': { name: 'AVAX', cost: 1000, colorVar: '--avax-color', symbol: 'A', cooldown: 20000, special: (p) => {
                    createFloatingText('Avalanche!', p.x, p.y, 'white');
                    const numShards = 15;
                    const spread = Math.PI / 2 * p.specialAreaMultiplier;
                    const moveVector = (inputManager.joystick.active || Object.values(inputManager.keys).some(k => k)) ? new Vector(inputManager.joystick.inputX + ((inputManager.keys.left ? -1:0) + (inputManager.keys.right ? 1:0)), inputManager.joystick.inputY + ((inputManager.keys.up ? -1:0) + (inputManager.keys.down ? 1:0))).normalize() : new Vector(0, -1);
                    const baseAngle = Math.atan2(moveVector.y, moveVector.x);
                    const startAngle = baseAngle - spread / 2;
                    for (let i = 0; i < numShards; i++) {
                        const p_options = { angle: startAngle + (spread * (i / (numShards - 1))), speed: 6, damage: 15 * p.globalDamageMultiplier * (1 + p.permanentDamageBonus) * p.levelDamageBonus * p.specialDamageMultiplier, lifespan: 600, pierce: p.projectilePierceCount };
                        entities.projectiles.push(new Projectile(p.x, p.y, 4, p_options));
                    }
                }, specialName: "Avalanche" },
                'ETH': { name: 'ETH', cost: 2000, colorVar: '--eth-color', symbol: '‚ô¶', cooldown: 30000, special: (p) => {
                    createFloatingText('Gas Burn!', p.x, p.y, 'white');
                    const radius = p.radius * 10 * p.specialAreaMultiplier;
                    entities.particles.push(new Particle(p.x, p.y, 'rgba(98, 126, 234, 0.5)', radius, 500));
                    entities.enemies.forEach(e => { if(Math.hypot(p.x - e.x, p.y - e.y) < radius) e.takeDamage(50 * p.globalDamageMultiplier * (1 + p.permanentDamageBonus) * p.levelDamageBonus * p.specialDamageMultiplier); });
                }, specialName: "Gas Burn" },
                'SOL': { name: 'SOL', cost: 3000, colorVar: '--sol-color', symbol: 'S', cooldown: 25000, special: (p) => {
                    createFloatingText('Network Haste!', p.x, p.y, 'white');
                    p.speed *= 2;
                    setTimeout(() => { if(p) p.speed /= 2; }, 3000);
                }, specialName: "Network Haste" },
                'AAVE': { name: 'AAVE', cost: 5000, colorVar: '--aave-color', symbol: 'üëª', cooldown: 25000, special: (p) => {
                    createFloatingText('Flash Loan!', p.x, p.y, 'white');
                    for (let i = 0; i < 8; i++) {
                        const p_options = { angle: (Math.PI / 4) * i, speed: 7, damage: 20 * p.globalDamageMultiplier * (1 + p.permanentDamageBonus) * p.levelDamageBonus * p.specialDamageMultiplier, lifespan: 800, pierce: p.projectilePierceCount };
                        entities.projectiles.push(new Projectile(p.x, p.y, 5, p_options));
                    }
                }, specialName: "Flash Loan" },
                'BTC': { name: 'BTC', cost: 10000, colorVar: '--btc-color', symbol: 'B', cooldown: 60000, special: (p) => {
                    createFloatingText('DIGITAL GOLD!', p.x, p.y, 'gold');
                    p.isInvincible = true;
                    setTimeout(() => { if(p) p.isInvincible = false; }, 5000);
                }, specialName: "Digital Gold" },
                'GRT': { name: 'GRT', cost: 1500, colorVar: '--grt-color', symbol: 'G', cooldown: 25000, special: () => {}, specialName: "Indexing" },
                'DOGE': { name: 'DOGE', cost: 500, colorVar: '--doge-color', symbol: 'D', cooldown: 25000, special: () => {}, specialName: "Much Wow" },
                'CRO': { name: 'CRO', cost: 1200, colorVar: '--cro-color', symbol: 'C', cooldown: 25000, special: () => {}, specialName: "Cronos Chain" },
                'ZIL': { name: 'ZIL', cost: 1800, colorVar: '--zil-color', symbol: 'Z', cooldown: 25000, special: () => {}, specialName: "Sharding" },
                'BNB': { name: 'BNB', cost: 2500, colorVar: '--bnb-color', symbol: 'N', cooldown: 25000, special: () => {}, specialName: "Smart Chain" },
                'HTM': { name: 'HTM', cost: 4000, colorVar: '--htm-color', symbol: 'H', cooldown: 25000, special: () => {}, specialName: "Liquid Stake" },
            };
            const bossProgression = [
                { name: 'AVAX', symbol: 'A', colorVar: '--avax-color'},
                { name: 'SOL', symbol: 'S', colorVar: '--sol-color'},
                { name: 'AAVE', symbol: 'üëª', colorVar: '--aave-color'},
                { name: 'GRT', symbol: 'G', colorVar: '--grt-color'},
                { name: 'DOGE', symbol: 'D', colorVar: '--doge-color'},
                { name: 'CRO', symbol: 'C', colorVar: '--cro-color'},
                { name: 'ZIL', symbol: 'Z', colorVar: '--zil-color'},
                { name: 'BNB', symbol: 'N', colorVar: '--bnb-color'},
                { name: 'HTM', symbol: 'H', colorVar: '--htm-color'},
                { name: 'ETH', symbol: '‚ô¶', colorVar: '--eth-color'},
                { name: 'BTC', symbol: 'B', colorVar: '--btc-color'}
            ];
            
            // --- FONCTIONS POUR LES AM√âLIORATIONS MULTIJOUEUR ---
            function setupMultiplayerUpgrades() {
                const container = dom.displays.multiplayerUpgradesContainer;
                container.innerHTML = ''; // Clear previous
                Object.keys(multiplayerUpgrades).forEach(key => {
                    const upgrade = multiplayerUpgrades[key];
                    const button = document.createElement('button');
                    button.id = `upgrade-btn-${key}`;
                    button.className = 'upgrade-button';
                    button.onclick = () => purchaseMultiplayerUpgrade(key);
                    
                    button.innerHTML = `
                        <span>${upgrade.icon} ${upgrade.name}</span>
                        <span class="upgrade-cost" id="upgrade-cost-${key}">${upgrade.cost}pt</span>
                    `;
                    container.appendChild(button);
                });
                updateMultiplayerUpgradeUI();
            }

            function updateMultiplayerUpgradeUI() {
                const humanPlayer = players[0];
                if (!humanPlayer) return;

                dom.displays.skillPoints.textContent = `Points: ${humanPlayer.skillPoints}`;

                Object.keys(multiplayerUpgrades).forEach(key => {
                    const upgrade = multiplayerUpgrades[key];
                    const button = document.getElementById(`upgrade-btn-${key}`);
                    if (button) {
                        const canAfford = humanPlayer.skillPoints >= upgrade.cost;
                        const isMaxLevel = upgrade.level >= upgrade.maxLevel;
                        button.disabled = !canAfford || isMaxLevel;

                        if (isMaxLevel) {
                            document.getElementById(`upgrade-cost-${key}`).textContent = 'MAX';
                        } else {
                            document.getElementById(`upgrade-cost-${key}`).textContent = `${upgrade.cost}pt`;
                        }
                    }
                });
            }

            window.purchaseMultiplayerUpgrade = function(key) {
                const humanPlayer = players[0];
                const upgrade = multiplayerUpgrades[key];
                if (humanPlayer && upgrade && humanPlayer.skillPoints >= upgrade.cost && upgrade.level < upgrade.maxLevel) {
                    humanPlayer.skillPoints -= upgrade.cost;
                    upgrade.level++;
                    audioManager.play('purchase');
                    updateMultiplayerUpgradeUI();
                }
            }
            
            // --- FONCTIONS POUR LA FUSION ---
            function updateFusionUI() {
                const container = dom.displays.fusionOptionsContainer;
                const title = dom.displays.fusionTitle;
                container.innerHTML = '';
                const humanPlayer = players[0];
                if (!humanPlayer) return;

                const fusionGroups = {}; // { 'triangle_0': [soldier1, soldier2], ... }
                entities.soldiers.forEach(s => {
                    if (s.owner === humanPlayer && s.fusionLevel < 20) {
                        const key = `${s.unitType}_${s.fusionLevel}`;
                        if (!fusionGroups[key]) {
                            fusionGroups[key] = [];
                        }
                        fusionGroups[key].push(s);
                    }
                });

                let hasFusionOptions = false;
                Object.keys(fusionGroups).forEach(key => {
                    if (fusionGroups[key].length >= 2) {
                        hasFusionOptions = true;
                        const [unitType, levelStr] = key.split('_');
                        const level = parseInt(levelStr);
                        const unitData = armyUnitData[unitType];
                        
                        const fusionCost = Math.pow(2, level); // Calcul du co√ªt
                        const canAfford = humanPlayer.wallet >= fusionCost;
                        const unitColor = getComputedStyle(document.documentElement).getPropertyValue(`--${unitData.color}-color`);

                        const button = document.createElement('button');
                        button.className = 'fusion-button';
                        button.onclick = () => performFusion(unitType, level);
                        
                        button.style.borderColor = unitColor;
                        button.style.color = unitColor;
                        button.disabled = !canAfford;
                        
                        button.innerHTML = `
                            <span class="unit-shape">${unitData.shape}</span>
                            <div class="unit-info">
                                <span class="unit-name" style="color: white;">Fusion Niv. ${level + 1}</span>
                                <span class="unit-cost">${fusionCost} $<span class="mvx-logo-inline">X</span></span>
                            </div>
                        `;
                        container.appendChild(button);
                    }
                });

                title.classList.toggle('hidden', !hasFusionOptions);
            }

            window.performFusion = function(unitType, level) {
                const humanPlayer = players[0];
                if (!humanPlayer) return;

                const fusionCost = Math.pow(2, level);
                if (humanPlayer.wallet < fusionCost) {
                    createFloatingText("Fonds insuffisants!", humanPlayer.x, humanPlayer.y, 'red');
                    return; 
                }
                
                const candidates = entities.soldiers.filter(s =>
                    s.owner === humanPlayer &&
                    s.unitType === unitType &&
                    s.fusionLevel === level
                );

                if (candidates.length >= 2) {
                    humanPlayer.wallet -= fusionCost;

                    const soldier1 = candidates[0];
                    const soldier2 = candidates[1];

                    entities.soldiers = entities.soldiers.filter(s => s !== soldier1 && s !== soldier2);

                    const newX = (soldier1.x + soldier2.x) / 2;
                    const newY = (soldier1.y + soldier2.y) / 2;
                    entities.soldiers.push(new Soldier(newX, newY, humanPlayer, unitType, level + 1));
                    
                    audioManager.play('levelUp'); // Fusion sound
                    updateFusionUI();
                }
            }

            // --- FONCTIONS POUR LE PENTAGRAMME ---
            function updatePentagrams(dt) {
                players.forEach(p => {
                    if (p.killCount >= 20 && !entities.pentagrams.some(pent => pent.owner === p)) {
                        const bounds = getQuadrantBoundaries(p.playerId);
                        const centerX = (bounds.minX + bounds.maxX) / 2;
                        const centerY = (bounds.minY + bounds.maxY) / 2;
                        entities.pentagrams.push(new Pentagram(centerX, centerY, p));
                    }
                });

                const humanPlayer = players[0];
                if (!humanPlayer) return;
                
                const playerPentagram = entities.pentagrams.find(p => p.owner === humanPlayer);
                if (playerPentagram) {
                    const dist = Math.hypot(humanPlayer.x - playerPentagram.x, humanPlayer.y - playerPentagram.y);
                    if (dist < playerPentagram.radius) {
                        humanPlayer.pentagramCharge = Math.min(10000, humanPlayer.pentagramCharge + dt);
                    } else {
                        humanPlayer.pentagramCharge = Math.max(0, humanPlayer.pentagramCharge - dt * 2); // D√©charge 2x plus vite
                    }

                    if (humanPlayer.pentagramCharge >= 10000) {
                        sendBossToOpponent(humanPlayer);
                        humanPlayer.killCount = 0;
                        humanPlayer.pentagramCharge = 0;
                        playerPentagram.lifespan = 0; // Remove pentagram
                    }
                }
            }

            function updatePentagramUI() {
                const humanPlayer = players[0];
                const container = dom.displays.pentagramChargeContainer;
                const bar = dom.displays.pentagramChargeBar;

                const playerPentagram = entities.pentagrams.find(p => p.owner === humanPlayer);
                if (playerPentagram && humanPlayer.pentagramCharge > 0) {
                    container.classList.remove('hidden');
                    const chargePercent = (humanPlayer.pentagramCharge / 10000) * 100;
                    bar.style.width = `${chargePercent}%`;
                } else {
                    container.classList.add('hidden');
                }
            }

            function sendBossToOpponent(sender) {
                const opponents = players.filter(p => p !== sender && p.hp > 0);
            
                if (opponents.length > 0) {
                    const maxWallet = Math.max(...opponents.map(p => p.wallet));
                    const targets = opponents.filter(p => p.wallet === maxWallet);
            
                    targets.forEach(target => {
                        const tier = Math.min(Math.floor((sender.level - 1) / 10), bossProgression.length - 1);
                        
                        const targetBounds = getQuadrantBoundaries(target.playerId);
                        const spawnX = targetBounds.minX + Math.random() * (targetBounds.maxX - targetBounds.minX);
                        const spawnY = targetBounds.minY + Math.random() * (targetBounds.maxY - targetBounds.minY);

                        entities.enemies.push(new MiniBoss(tier, spawnX, spawnY, target.playerId, true));
                        
                        if(target.playerId === 1) { 
                             createFloatingText('BOSS INVOQU√â SUR VOUS !', target.x, target.y, 'var(--boss-color)');
                        }
                    });
            
                    createFloatingText('BOSS ENVOY√â!', sender.x, sender.y, 'var(--boss-color)');
                }
            }


            // --- GESTION DE L'AUTHENTIFICATION ---
            const loginScreen = document.getElementById('login-screen');
            const mainMenuScreen = document.getElementById('main-menu-screen');
            const loginForm = document.getElementById('login-form');
            const usernameInput = document.getElementById('username');
            const passwordInput = document.getElementById('password');
            const confirmPasswordGroup = document.getElementById('confirm-password-group');
            const confirmPasswordInput = document.getElementById('confirm-password');
            const loginError = document.getElementById('login-error');
            const loginTitle = document.getElementById('login-title');
            const submitButton = document.getElementById('submit-button');
            const toggleText = document.getElementById('toggle-text');
            const passwordStrengthBar = document.getElementById('password-strength-bar');
            const passwordStrengthText = document.getElementById('password-strength-text');

            let isRegisterMode = false;

            function updateToggleLink() {
                const link = isRegisterMode 
                    ? toggleText.querySelector('#toggle-to-login') 
                    : toggleText.querySelector('#toggle-to-register');
                
                if (link) {
                    link.addEventListener('click', () => switchToRegister(!isRegisterMode));
                }
            }

            function switchToRegister(isRegister) {
                isRegisterMode = isRegister;
                loginForm.reset();
                loginError.textContent = '';
                loginTitle.textContent = isRegister ? 'Inscription' : 'Connexion';
                submitButton.textContent = isRegister ? 'S\'inscrire' : 'Se connecter';
                confirmPasswordGroup.classList.toggle('hidden', !isRegister);
                passwordStrengthBar.style.width = '0%';
                passwordStrengthText.textContent = '';
                
                toggleText.innerHTML = isRegister 
                    ? 'D√©j√† un compte ? <span class="toggle-link" id="toggle-to-login">Connectez-vous</span>' 
                    : 'Pas encore de compte ? <span class="toggle-link" id="toggle-to-register">Inscrivez-vous</span>';
                
                updateToggleLink();
            }
            
            updateToggleLink(); // Initial setup for the first link

            passwordInput.addEventListener('input', () => {
                if (isRegisterMode) {
                    checkPasswordStrength(passwordInput.value);
                }
            });

            function checkPasswordStrength(password) {
                let score = 0;
                if (!password) {
                    passwordStrengthBar.style.width = '0%';
                    passwordStrengthText.textContent = '';
                    return;
                }
                if (password.length >= 8) score++;
                if (/[a-z]/.test(password)) score++;
                if (/[A-Z]/.test(password)) score++;
                if (/[0-9]/.test(password)) score++;
                if (/[^A-Za-z0-9]/.test(password)) score++;

                let strength = '';
                let color = '';

                switch (score) {
                    case 0: case 1: case 2:
                        strength = 'Faible';
                        color = '#e74c3c'; // red
                        break;
                    case 3:
                        strength = 'Moyen';
                        color = '#f1c40f'; // yellow
                        break;
                    case 4:
                        strength = 'Fort';
                        color = '#2ecc71'; // green
                        break;
                    case 5:
                        strength = 'Tr√®s fort';
                        color = '#00f5d4'; // primary
                        break;
                }
                passwordStrengthBar.style.width = (score / 5) * 100 + '%';
                passwordStrengthBar.style.backgroundColor = color;
                passwordStrengthText.textContent = `Force : ${strength}`;
                passwordStrengthText.style.color = color;
            }

            let socket; // D√©clarer la socket sans l'initialiser

            function initializeSocket(serverUrl) {
                if (socket && socket.connected) {
                    socket.disconnect();
                }

                const isMultiplayerMenu = dom.screens.multiplayerMode.style.display === 'block';
                const statusDisplay = isMultiplayerMenu ? dom.displays.connectionStatus : loginError;

                statusDisplay.textContent = 'Connexion en cours...';
                statusDisplay.style.color = 'white';
                if (isMultiplayerMenu) {
                    dom.buttons.createPrivateGame.disabled = true;
                    dom.buttons.joinPrivateGame.disabled = true;
                } else {
                    submitButton.disabled = true;
                }

                console.log(`Tentative de connexion au serveur Socket.IO sur ${serverUrl}...`);
                socket = io(serverUrl, {
                    reconnection: true,
                    reconnectionAttempts: 3,
                    reconnectionDelay: 1000,
                    timeout: 5000,
                });

                // --- GESTION DES √âV√âNEMENTS SOCKET --- 
                socket.on('connect', () => {
                    console.log('SUCC√àS : Connect√© au serveur Socket.IO avec l\'ID :', socket.id);
                    statusDisplay.textContent = 'Connect√© !';
                    statusDisplay.style.color = 'lime';
                    if (isMultiplayerMenu) {
                        dom.buttons.createPrivateGame.disabled = false;
                        dom.buttons.joinPrivateGame.disabled = false;
                    } else {
                        submitButton.disabled = false;
                    }
                });

                socket.on('connect_error', (err) => {
                    console.error('ERREUR : La connexion au serveur Socket.IO a √©chou√©.', err);
                    statusDisplay.textContent = `Erreur de connexion.`;
                    statusDisplay.style.color = 'red';
                    if (isMultiplayerMenu) {
                        dom.buttons.createPrivateGame.disabled = true;
                        dom.buttons.joinPrivateGame.disabled = true;
                    } else {
                        submitButton.disabled = false;
                    }
                });

                socket.on('register-success', (data) => {
                    loginError.style.color = 'var(--health-color)';
                    loginError.textContent = `Inscription r√©ussie pour ${data.username} ! Vous pouvez maintenant vous connecter.`;
                    submitButton.disabled = false; 
                    switchToRegister(false);
                });

                socket.on('register-error', (message) => {
                    loginError.style.color = '#e74c3c';
                    loginError.textContent = message;
                    submitButton.disabled = false;
                });

                socket.on('login-success', (data) => {
                    submitButton.disabled = false;
                    onLoginSuccess(data);
                });

                socket.on('login-error', (message) => {
                    loginError.style.color = '#e74c3c';
                    loginError.textContent = message;
                    submitButton.disabled = false;
                });

                socket.on('gameCreated', ({ gameId, players, map }) => {
                    dom.displays.gameIdDisplay.textContent = gameId;
                    updatePlayerList(players, map);
                    showScreen('waitingRoom');
                });

                socket.on('updatePlayerList', ({ players, map }) => {
                    updatePlayerList(players, map);
                });

                socket.on('gameStarted', () => {
                    gameMode = 'multiplayer';
                    startGame(selectedMap);
                });

                socket.on('joinError', (message) => {
                    alert(message); // Simple alert for now
                });
            }

            loginForm.addEventListener('submit', (e) => {
                e.preventDefault();
                loginError.textContent = '';
                submitButton.disabled = true;
                const username = usernameInput.value;
                const password = passwordInput.value;
                
                // Utiliser l'URL du serveur par d√©faut pour la connexion/inscription
                // Cette partie sera modifi√©e plus tard pour utiliser l'URL des autres √©crans
                const serverUrl = "https://crypto-survivor.onrender.com"; 
                initializeSocket(serverUrl);

                // On attend un court instant que la connexion s'√©tablisse
                setTimeout(() => {
                    if (!socket.connected) {
                        // Si la connexion n'est pas √©tablie apr√®s un d√©lai, on ne continue pas.
                        // L'erreur est d√©j√† g√©r√©e par 'connect_error'
                        return;
                    }

                    if (isRegisterMode) {
                        const score = checkPasswordStrength(password);
                        if (score < 3) {
                            loginError.textContent = 'Le mot de passe est trop faible.';
                            submitButton.disabled = false;
                            return;
                        }
                        if (password !== confirmPasswordInput.value) {
                            loginError.textContent = 'Les mots de passe ne correspondent pas.';
                            submitButton.disabled = false;
                            return;
                        }
                        socket.emit('register', { username, password });
                    } else {
                        socket.emit('login', { username, password });
                    }
                }, 500); // D√©lai de 500ms pour la connexion
            });

            function onLoginSuccess(playerData) {
                currentPlayer = playerData; // Stocker les donn√©es du joueur
                loginScreen.classList.remove('active');
                mainMenuScreen.classList.add('active');

                // Affiche le message de bienvenue
                const playerGreeting = document.getElementById('player-greeting');
                if (playerGreeting) {
                    playerGreeting.textContent = `Bienvenue, ${currentPlayer.username} !`;
                }

                // Lancement du jeu apr√®s connexion
                init(); 
            }
        });
    </script>
</body>
</html>
