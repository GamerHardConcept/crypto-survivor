<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crypto Survivor: To The Moon</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    
    <!-- Ajout de la bibliothèque Tone.js pour l'audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Menu Principal -->
    <div id="main-menu-screen" class="screen active">
        <div class="screen-content">
            <h1>Crypto Survivor</h1>
            <div class="menu-buttons">
                <button id="start-game-button" class="action-button">Survivor Mode</button>
                <button id="multiplayer-button" class="action-button">Multijoueur</button>
                <button id="shop-button" class="action-button">Boutique</button>
                <button id="options-button" class="action-button" disabled>Options</button>
            </div>
        </div>
    </div>

    <!-- Écran de Boutique -->
    <div id="shop-screen" class="screen">
        <div class="screen-content">
            <h1>Boutique</h1>
            <p>Améliorations Permanentes</p>
            <div id="shop-wallet-display">0</div>
            <div id="shop-items-container">
                <!-- Les objets de la boutique sont injectés ici par JavaScript -->
            </div>
            <button id="back-to-menu-button" class="action-button">Retour</button>
        </div>
    </div>

    <!-- Écran de sélection du personnage -->
    <div id="character-selection-screen" class="screen">
        <div class="screen-content">
            <h1>Crypto Survivor</h1>
            <p>Choisissez votre Crypto</p>
            <div class="character-choices" id="character-choices-container">
                <!-- Les personnages sont injectés ici par JavaScript -->
            </div>
            <button id="back-to-menu-from-char-select-button" class="action-button">Retour</button>
        </div>
    </div>

    <!-- Écran de Sélection de Mode Multijoueur -->
    <div id="multiplayer-mode-screen" class="screen">
        <div class="screen-content">
            <h2>Choisissez un mode</h2>
            <div class="menu-buttons">
                <button id="army-attack-button" class="action-button">Army Attaque</button>
                <button class="action-button" disabled>Tower Defence</button>
                <button class="action-button" disabled>Coming Soon</button>
                <button class="action-button" disabled>Coming Soon</button>
            </div>
            <button id="back-to-menu-from-mode-select-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
        </div>
    </div>

    <!-- Écran de Sélection de Carte -->
    <div id="map-selection-screen" class="screen">
        <div class="screen-content">
            <h2>Choisissez une carte</h2>
            <div class="map-choices">
                <div class="map-option" data-map-id="quadrant_4p">
                    <div class="map-preview">
                        <div class="map-preview-line-v"></div>
                        <div class="map-preview-line-h"></div>
                    </div>
                    <strong>Arène 4 Joueurs</strong>
                    <span>4 Joueurs</span>
                </div>
                 <div class="map-option" data-map-id="vertical_2p">
                    <div class="map-preview">
                        <div class="map-preview-line-h"></div>
                    </div>
                    <strong>Duel Vertical</strong>
                    <span>2 Joueurs</span>
                </div>
            </div>
            <div class="menu-buttons">
                 <button id="next-from-map-select-button" class="action-button" disabled>Suivant</button>
                 <button id="back-to-menu-from-map-select-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
            </div>
        </div>
    </div>
    
    <!-- Écran du Lobby Multijoueur -->
    <div id="multiplayer-lobby-screen" class="screen">
        <div class="screen-content">
            <h2>Multijoueur</h2>
            <div class="form-group">
                <label for="player-name-input">Pseudo</label>
                <input type="text" id="player-name-input" placeholder="Votre pseudo..." maxlength="12">
            </div>
            <div class="form-group">
                <label for="game-id-input">ID de la partie</label>
                <input type="text" id="game-id-input" placeholder="Entrez un ID pour rejoindre...">
            </div>
            <button id="join-game-button" class="action-button" disabled>Rejoindre</button>
            <button id="create-game-button" class="action-button">Créer une partie</button>
            <button id="back-to-menu-from-lobby-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
        </div>
    </div>

    <!-- Écran du Salon d'attente -->
    <div id="waiting-room-screen" class="screen">
        <div class="screen-content">
            <h2>Salon d'attente</h2>
            <p id="waiting-room-info">ID de la partie : <span id="game-id-display"></span></p>
            <h3>Joueurs (1/4)</h3>
            <ul id="player-list">
                <!-- Joueurs simulés -->
                <li>Votre Pseudo (Hôte)</li>
            </ul>
            <div class="menu-buttons">
                <button id="start-vs-ai-button" class="action-button">Jouer contre l'IA</button>
                <button id="start-multiplayer-game-button" class="action-button" disabled>Lancer la partie (2+ Joueurs)</button>
                <button id="back-to-lobby-from-waiting-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
            </div>
        </div>
    </div>


    <!-- Écran de Pause -->
    <div id="pause-screen" class="screen">
        <div class="screen-content">
            <h2>PAUSE</h2>
            <div class="menu-buttons">
                <button id="resume-button" class="action-button">Continuer</button>
                <button id="restart-from-pause-button" class="action-button">Recommencer</button>
                <button id="main-menu-from-pause-button" class="action-button">Menu Principal</button>
            </div>
        </div>
    </div>

    <!-- Écran de Confirmation pour Quitter -->
    <div id="confirm-quit-screen" class="screen">
        <div class="screen-content">
            <h2>Quitter la partie ?</h2>
            <p>Votre progression dans cette partie sera perdue.</p>
            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="confirm-quit-yes-button" class="action-button">Oui</button>
                <button id="confirm-quit-no-button" class="action-button" style="background-color: var(--disabled-color);">Non</button>
            </div>
        </div>
    </div>

    <!-- Interface du jeu (HUD) -->
    <div id="game-hud" class="hidden">
        <div id="hud-left-column">
            <div id="stats-container">
                <div id="stats-left">
                    <div>LVL: <span id="player-level">1</span></div>
                    <div>$<span class="mvx-logo-inline">X</span> <span id="player-wallet">0</span></div>
                </div>
                <div id="game-timer">00:00</div>
            </div>
            <div id="top-health-bar">
                <div id="top-health-bar-fill"></div>
                <span id="top-health-bar-text">100 / 100</span>
            </div>
            <div id="xp-bar-container">
                <div id="xp-bar"></div>
                <span id="xp-bar-text">0 / 10</span>
            </div>
        </div>
        <div id="hud-right-column">
            <canvas id="minimap-canvas" width="80" height="80"></canvas>
            <button id="pause-button" class="game-ui-button">||</button>
        </div>
    </div>
    <div id="bonus-timer" class="hidden"></div>

    <!-- Panneau d'Améliorations (Gauche) -->
    <div id="upgrade-panel" class="side-panel hidden">
        <button id="upgrade-panel-toggle" class="side-panel-toggle"><span>◀</span></button>
        <div id="skill-points-display">Points: 0</div>
        <div id="multiplayer-upgrades-container">
            <!-- Les améliorations seront injectées ici -->
        </div>
    </div>

    <!-- Panneau d'Achat d'Armée (Droite) -->
    <div id="army-purchase-panel" class="side-panel hidden">
        <button id="army-panel-toggle" class="side-panel-toggle"><span>▶</span></button>
        <h3>Construire Armée</h3>
        <div class="army-unit-button" data-unit="triangle">
            <span class="unit-shape">▲</span>
            <div class="unit-info">
                <span class="unit-name">Mitrailleur</span>
                <span class="unit-cost">50 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <div class="army-unit-button" data-unit="square">
            <span class="unit-shape">■</span>
            <div class="unit-info">
                <span class="unit-name">Artilleur</span>
                <span class="unit-cost">100 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <div class="army-unit-button" data-unit="rectangle">
            <span class="unit-shape">▬</span>
            <div class="unit-info">
                <span class="unit-name">Lance-Missiles</span>
                <span class="unit-cost">150 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <h3 id="fusion-title" class="hidden">Fusionner</h3>
        <div id="fusion-options-container">
              <!-- Les options de fusion seront injectées ici -->
        </div>
    </div>


    <!-- Écran de montée de niveau -->
    <div id="level-up-screen" class="screen">
        <div class="screen-content">
            <h2 id="level-up-title">LEVEL UP!</h2>
            <p id="level-up-subtitle">Choisissez une seule amélioration :</p>
            <div id="level-up-options"></div>
            <button id="confirm-upgrade-button" class="action-button hidden">Confirmer</button>
        </div>
    </div>

    <!-- Écran de fin de partie -->
    <div id="game-over-screen" class="screen">
        <div class="screen-content">
            <h2 id="game-over-title">LIQUIDATED!</h2>
            <div id="survivor-stats">
                <p>Vous avez survécu <span id="final-time">00:00</span>.</p>
                <p>Niveau final : <span id="final-level">1</span></p>
                <p>Gains : <span id="final-gain">0</span> $<span class="mvx-logo-inline">X</span></p>
            </div>
            <div id="game-over-buttons" class="menu-buttons">
                <!-- Bouton pour le mode Survivor -->
                <button id="restart-button" class="action-button">Menu Principal</button>
                <!-- Nouveaux boutons pour le mode Army Attack -->
                <button id="game-over-lobby-button" class="action-button hidden">Lobby</button>
                <button id="game-over-spectate-button" class="action-button hidden">Mode Spectateur</button>
                <button id="game-over-quit-button" class="action-button hidden">Menu Principal</button>
            </div>
        </div>
    </div>
    
    <!-- Affichages UI en jeu -->
    <div id="passive-upgrades-display" class="hidden"></div>
    <div id="weapon-display-ui" class="hidden"></div>

    <!-- Éléments du jeu -->
    <canvas id="game-canvas"></canvas>
    <div id="joystick-container"><div id="joystick-handle"></div></div>
    <button id="special-ability-button" class="hidden">🚀</button>
    <button id="mute-button" class="game-ui-button">🎵</button>
    
    <!-- Barre de chargement du Pentagramme -->
    <div id="pentagram-charge-container" class="hidden">
        <div id="pentagram-charge-bar"></div>
        <span id="pentagram-charge-text">Invocation...</span>
    </div>

    <!-- Scripts du jeu -->
    <script src="js/constants.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/audio.js"></script>
    <script src="js/save.js"></script>
    <script src="js/entities.js"></script>
    <script src="js/weapons.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
                    ]
                },
                health: {
                    name: "Bonus de Vie",
                    icon: "💚",
                    levels: [
                        { bonus: 0.10, cost: 10000 },
                        { bonus: 0.20, cost: 30000 },
                        { bonus: 0.30, cost: 60000 },
                        { bonus: 0.50, cost: 180000 },
                        { bonus: 0.75, cost: 540000 },
                    ]
                },
                xpGain: {
                    name: "Bonus de Gain d'XP",
                    icon: "💙",
                    levels: [
                        { bonus: 0.10, cost: 10000 },
                        { bonus: 0.20, cost: 30000 },
                        { bonus: 0.30, cost: 60000 },
                        { bonus: 0.50, cost: 180000 },
                        { bonus: 0.75, cost: 540000 },
                    ]
                },
                attackSpeed: {
                    name: "Bonus de Vitesse d'Attaque",
                    icon: "💛",
                    levels: [
                        { bonus: 0.10, cost: 10000 }, // bonus = réduction du cooldown
                        { bonus: 0.20, cost: 30000 },
                        { bonus: 0.30, cost: 60000 },
                        { bonus: 0.50, cost: 180000 },
                        { bonus: 0.75, cost: 540000 },
                    ]
                }
            };

            const armyUnitData = {
                triangle: {
                    cost: 50,
                    shape: '▲',
                    damage: 10,
                    fireRate: 1000, // ms
                    projectileSpeed: 4,
                    color: 'mvx'
                },
                square: {
                    cost: 100,
                    shape: '■',
                    damage: 25,
                    fireRate: 1500,
                    projectileSpeed: 3,
                    color: 'sol'
                },
                rectangle: {
                    cost: 150,
                    shape: '▬',
                    damage: 40,
                    fireRate: 2000,
                    projectileSpeed: 5,
                    color: 'eth'
                }
            };

            // --- Configuration des améliorations multijoueur ---
            let multiplayerUpgrades = {
                soldierDamage: {
                    name: "Dégâts Soldats",
                    icon: "💥",
                    level: 0,
                    maxLevel: 10,
                    cost: 1,
                    bonus: 0.15 // +15% par niveau
                },
                soldierFireRate: {
                    name: "Cadence Soldats",
                    icon: "⏱️",
                    level: 0,
                    maxLevel: 10,
                    cost: 1,
                    bonus: 0.10 // -10% cooldown par niveau
                }
            };
            
            // --- CLASSES DU JEU ---

            class Vector {
                constructor(x = 0, y = 0) { this.x = x; this.y = y; }
                magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
                normalize() {
                    const mag = this.magnitude();
                    if (mag > 0) { this.x /= mag; this.y /= mag; }
                    return this;
                }
            }
            
            class Entity {
                constructor(x, y, radius) {
                    Object.assign(this, { x, y, radius });
                }
                update(dt) { /* a implémenter par les enfants */ }
                draw() { /* a implémenter par les enfants */ }
            }

            class Player extends Entity {
                constructor(charType, playerId = 1) {
                    super(0, 0, 15); // La position sera définie dans resetGameState
                    this.playerId = playerId;
                    this.charType = charType;
                    const charData = characterData[this.charType];

                    // Application des bonus permanents
                    const permBonuses = getPermanentBonuses();
                    this.permanentDamageBonus = permBonuses.damage;
                    this.permanentHealthBonus = permBonuses.health;
                    this.permanentXpGainBonus = permBonuses.xpGain;
                    this.permanentCooldownBonus = permBonuses.attackSpeed;

                    // Stats de base
                    this.speed = 3;
                    this.speedMultiplier = 1.0;
                    this.baseMaxHp = 100;
                    this.maxHp = this.baseMaxHp * (1 + this.permanentHealthBonus);
                    this.hp = this.maxHp;
                    this.level = 1;
                    this.xp = 0;
                    this.xpToNextLevel = 10;
                    this.wallet = 0;
                    this.levelDamageBonus = 1.0; 
                    this.soldierOrbitAngle = 0; // Pour la formation des soldats
                    this.skillPoints = 0; // Pour le mode Army Attack
                    this.killCount = 0;
                    this.pentagramCharge = 0;
                    
                    // Armes et améliorations
                    this.weapons = [];
                    this.upgradesToPick = 0;
                    this.acquiredPassives = [];
                    this.extraUpgradeCharges = 0;
                    
                    // Multiplicateurs globaux
                    this.globalDamageMultiplier = 1.0;
                    this.globalCooldownMultiplier = 1.0;
                    this.projectileLifespanBonus = 1.0;
                    this.projectilePierceCount = 0;
                    this.xpGainBonus = 1.0; 
                    this.projectileCountBonus = 0;
                    this.pickupRadius = 50;
                    this.doubleXpChance = 0;
                    
                    // Multiplicateurs pour le super pouvoir
                    this.specialDamageMultiplier = 1.0;
                    this.specialCooldownMultiplier = 1.0;
                    this.specialAreaMultiplier = 1.0;

                    // État
                    this.specialCooldown = 0;
                    this.isInvincible = false;
                    this.isBonusLevelUp = false; 
                    this.lastBossSpawnLevel = 0;
                    
                    // Propriétés du personnage
                    this.color = getComputedStyle(document.documentElement).getPropertyValue(charData.colorVar);
                    this.symbol = charData.symbol;
                    this.specialMaxCooldown = charData.cooldown;
                }

                update(dt) {
                    // Mouvement du joueur humain
                    const moveX = (inputManager.keys.left ? -1 : 0) + (inputManager.keys.right ? 1 : 0);
                    const moveY = (inputManager.keys.up ? -1 : 0) + (inputManager.keys.down ? 1 : 0);
                    const keyboardMove = new Vector(moveX, moveY).normalize();
                    const joystickMove = new Vector(inputManager.joystick.inputX, inputManager.joystick.inputY);
                    
                    let finalMove = (joystickMove.magnitude() > 0) ? joystickMove : keyboardMove;

                    this.x += finalMove.x * this.speed * this.speedMultiplier;
                    this.y += finalMove.y * this.speed * this.speedMultiplier;

                    // Limites du monde
                    const bounds = getQuadrantBoundaries(this.playerId);
                    this.x = Math.max(bounds.minX + this.radius, Math.min(bounds.maxX - this.radius, this.x));
                    this.y = Math.max(bounds.minY + this.radius, Math.min(bounds.maxY - this.radius, this.y));
                    
                    // Mise à jour des armes et du cooldown
                    this.weapons.forEach(weapon => weapon.update(dt));
                    if (this.specialCooldown > 0) {
                        this.specialCooldown -= dt;
                        dom.buttons.specialAbility.classList.add('on-cooldown');
                    } else {
                        dom.buttons.specialAbility.classList.remove('on-cooldown');
                    }
                }

                draw() {
                    // Zone de collecte
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.pickupRadius, 0, Math.PI * 2);
                    ctx.fill();

                    // Invincibilité
                    if(this.isInvincible) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Joueur
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Symbole
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 20px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    if (this.charType === 'MVX') {
                        ctx.rotate(Math.PI / 2); // Rotation de 90 degrés
                    }
                    ctx.fillText(this.symbol, 0, 2);
                    ctx.restore();
                }
                
                takeDamage(amount) {
                    if (this.isInvincible) return;
                    audioManager.play('playerHit');
                    this.hp -= amount;
                    if (this.playerId === 1) { // Seulement pour le joueur humain
                        createFloatingText('FUD!', this.x, this.y, 'red');
                    }
                    if (this.hp <= 0) { 
                        this.hp = 0; 
                    }
                }

                gainXp(amount) {
                    const totalXpBonus = this.xpGainBonus * (1 + this.permanentXpGainBonus);
                    this.xp += amount * totalXpBonus;
                    if (activeMiniBoss) return; 

                    while (this.xp >= this.xpToNextLevel) {
                        this.levelUp();
                    }
                }

                levelUp() {
                    audioManager.play('levelUp');
                    this.xp -= this.xpToNextLevel;
                    this.level++;
                    this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5);
                    
                    this.maxHp += 10;
                    this.hp = this.maxHp; 
                    
                    if (this.level % 5 === 0) {
                        this.levelDamageBonus += 0.05;
                        if (this.playerId === 1) createFloatingText('+5% Dégâts!', this.x, this.y, 'orange');
                    }
                    
                    if (this.playerId === 1) createFloatingText('LEVEL UP!', this.x, this.y, 'var(--xp-color)');
                    
                    const explosionRadius = 300;
                    const explosionDamage = 100 * 10;
                    entities.particles.push(new Particle(this.x, this.y, 'var(--primary-color)', explosionRadius, 500));
                    audioManager.play('explosion');
                    
                    entities.enemies.forEach(e => {
                        if (Math.hypot(this.x - e.x, this.y - e.y) < explosionRadius) {
                            if (e instanceof MiniBoss) {
                                e.takeDamage(explosionDamage);
                            } else {
                                e.hp = 0;
                            }
                        }
                    });

                    if (gameMode === 'armyAttack') {
                        this.skillPoints = (this.skillPoints || 0) + 1;
                        if (this.playerId === 1) {
                            updateMultiplayerUpgradeUI();
                            createFloatingText('+1 Point!', this.x, this.y, 'gold');
                        }
                        return;
                    }

                    spawnBonusUpgrade();
                    gameState = 'levelUp';
                    this.upgradesToPick = 1; 
                    displayLevelUpOptions();
                }

                useSpecial() {
                    if (this.specialCooldown <= 0 && players[0]) {
                        this.specialCooldown = this.specialMaxCooldown * this.specialCooldownMultiplier;
                        characterData[this.charType].special(this);
                    }
                }
            }

            class BotPlayer extends Player {
                constructor(charType, playerId) {
                    super(charType, playerId);
                    this.optimalRange = 200;
                    this.purchaseTimer = 5000 + Math.random() * 5000;
                }

                update(dt) {
                    if (this.hp <= 0) return;

                    // --- AI Decision Making & Movement ---
                    const enemiesInQuadrant = entities.enemies.filter(e => e.quadrant === this.playerId && e.hp > 0);
                    let finalMove = new Vector(0, 0);

                    if (enemiesInQuadrant.length > 0) {
                        let repulsion = new Vector(0, 0);
                        let attraction = new Vector(0, 0);
                        const DANGER_RADIUS = 120;
                        const WALL_AVOID_RADIUS = 60;

                        // 1. Repulsion from all nearby enemies
                        enemiesInQuadrant.forEach(enemy => {
                            const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                            if (dist < DANGER_RADIUS) {
                                let fleeVector = new Vector(this.x - enemy.x, this.y - enemy.y);
                                fleeVector.normalize();
                                // La force de répulsion est inversement proportionnelle à la distance
                                fleeVector.x /= (dist + 0.1); 
                                fleeVector.y /= (dist + 0.1);
                                repulsion.x += fleeVector.x;
                                repulsion.y += fleeVector.y;
                            }
                        });

                        // 2. Attraction/Repulsion to the closest enemy to maintain optimal range
                        const closestEnemy = enemiesInQuadrant.reduce((closest, enemy) => {
                            const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                            return dist < closest.dist ? { dist, enemy } : closest;
                        }, { dist: Infinity }).enemy;

                        if (closestEnemy) {
                            const distToClosest = Math.hypot(this.x - closestEnemy.x, this.y - closestEnemy.y);
                            if (distToClosest > this.optimalRange) { // Trop loin, on s'approche
                                attraction.x = closestEnemy.x - this.x;
                                attraction.y = closestEnemy.y - this.y;
                            } else { // Trop près, on recule
                                attraction.x = this.x - closestEnemy.x;
                                attraction.y = this.y - closestEnemy.y;
                            }
                        }
                        
                        // 3. Wall Avoidance
                        const bounds = getQuadrantBoundaries(this.playerId);
                        if (this.x < bounds.minX + WALL_AVOID_RADIUS) repulsion.x += 1;
                        if (this.x > bounds.maxX - WALL_AVOID_RADIUS) repulsion.x -= 1;
                        if (this.y < bounds.minY + WALL_AVOID_RADIUS) repulsion.y += 1;
                        if (this.y > bounds.maxY - WALL_AVOID_RADIUS) repulsion.y -= 1;

                        // 4. Combine forces (giving much more weight to repulsion)
                        repulsion.normalize();
                        attraction.normalize();
                        finalMove.x = (repulsion.x * 2.0) + (attraction.x * 0.8);
                        finalMove.y = (repulsion.y * 2.0) + (attraction.y * 0.8);

                    } 
                    
                    finalMove.normalize();
                    this.x += finalMove.x * this.speed * 0.7;
                    this.y += finalMove.y * this.speed * 0.7;

                    // --- AI Purchasing ---
                    this.purchaseTimer -= dt;
                    if (this.purchaseTimer <= 0) {
                        const soldiersOwned = entities.soldiers.filter(s => s.owner === this).length;
                        if (soldiersOwned < 10) { // Max 10 soldiers
                             const unitTypes = Object.keys(armyUnitData);
                             const randomUnitType = unitTypes[Math.floor(Math.random() * unitTypes.length)];
                             const cost = armyUnitData[randomUnitType].cost;
                             if (this.wallet >= cost) {
                                 this.wallet -= cost;
                                 const spawnX = this.x + (Math.random() - 0.5) * 40;
                                 const spawnY = this.y + (Math.random() - 0.5) * 40;
                                 entities.soldiers.push(new Soldier(spawnX, spawnY, this, randomUnitType));
                             }
                        }
                        this.purchaseTimer = 10000 + Math.random() * 5000; // Reset timer
                    }


                    // Limites du monde (clamp position to be safe)
                    const bounds = getQuadrantBoundaries(this.playerId);
                    this.x = Math.max(bounds.minX + this.radius, Math.min(bounds.maxX - this.radius, this.x));
                    this.y = Math.max(bounds.minY + this.radius, Math.min(bounds.maxY - this.radius, this.y));

                    // Mise à jour des armes
                    this.weapons.forEach(weapon => weapon.update(dt));
                }

                draw() {
                    super.draw(); // Dessine le joueur normalement
                    // Ajoute une indication "BOT"
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(`BOT ${this.playerId}`, this.x, this.y - this.radius - 5);
                }
            }
            
            class Enemy extends Entity {
                constructor(tier = 0, x, y, quadrant) {
                    super(x, y, 12);
                    this.quadrant = quadrant;
                    this.bounds = getQuadrantBoundaries(this.quadrant);
                    
                    const tierData = bossProgression[tier];
                    this.tier = tier;
                    this.speed = 1 + Math.random() * 0.5 + tier * 0.3;
                    this.hp = 20 * Math.pow(11, tier);
                    this.damage = 5 * Math.pow(1.5, tier);
                    this.walletValue = 1 * (tier + 1);
                    this.xpValue = 1 * Math.pow(6, tier);
                    this.color = getComputedStyle(document.documentElement).getPropertyValue(tierData.colorVar);
                    this.symbol = tierData.symbol;
                    this.hitTimer = 0;
                    this.targetPlayer = players.find(p => p.playerId === this.quadrant);
                }

                update(dt) {
                    if (this.hitTimer > 0) {
                        this.hitTimer -= dt;
                    }
                    
                    if (!this.targetPlayer || this.targetPlayer.hp <= 0) {
                        return; // Arrête de bouger si la cible est morte
                    }

                    const angle = Math.atan2(this.targetPlayer.y - this.y, this.targetPlayer.x - this.x);
                    this.x += Math.cos(angle) * this.speed;
                    this.y += Math.sin(angle) * this.speed;

                    // Respecter les murs du quadrant
                    this.x = Math.max(this.bounds.minX + this.radius, Math.min(this.bounds.maxX - this.radius, this.x));
                    this.y = Math.max(this.bounds.minY + this.radius, Math.min(this.bounds.maxY - this.radius, this.y));
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    if (this.hitTimer > 0) {
                        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.symbol, this.x, this.y);
                }

                takeDamage(amount) {
                    this.hp -= amount;
                    this.hitTimer = 100;
                    if (this.hp <= 0) {
                        const killer = players.find(p => p.playerId === this.quadrant);
                        if (killer) {
                           killer.wallet += this.walletValue;
                           killer.killCount++;
                           if (killer.playerId === 1) { // Only human player gets XP
                                audioManager.play('enemyDefeat');
                                const isDouble = Math.random() < killer.doubleXpChance;
                                entities.xpOrbs.push(new XpOrb(this.x, this.y, this.xpValue, isDouble));
                           }
                        }
                    }
                }
            }

            class TankEnemy extends Enemy {
                constructor(tier = 0, x, y, quadrant) {
                    super(tier, x, y, quadrant); 
                    this.radius = 18;
                    this.hp = 500 * Math.pow(11, tier);
                    this.xpValue *= 4;
                }
            }
            
            class MiniBoss extends Enemy {
                constructor(tier, x, y, quadrant, isDemiBoss = false) {
                    super(tier, x, y, quadrant); 
                    this.isDemiBoss = isDemiBoss;
                    const tierData = bossProgression[tier];
                    this.name = tierData.name;
                    this.radius = isDemiBoss ? 25 : 40;
                    this.hp = (isDemiBoss ? 1000 : 3000) * Math.pow(11, tier);
                    this.maxHp = this.hp;
                    this.xpValue = (isDemiBoss ? 15 : 50) * Math.pow(6, tier);
                    this.walletValue = (isDemiBoss ? 25 : 100) * (tier + 1);
                    this.speed *= 1.25;
                    
                    this.spikeRotation1 = 0;
                    this.spikeRotation2 = 0;
                    this.spikeAnimationTimer = 0;
                }

                update(dt) {
                    // La logique de ciblage du parent est globale, ce qui est ok pour un boss
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    this.targetPlayer = humanPlayer;
                    super.update(dt);
                    this.spikeRotation1 += 0.02; 
                    this.spikeRotation2 -= 0.03;
                    this.spikeAnimationTimer += dt;
                }

                draw() {
                    // ... (le dessin du boss reste le même)
                }

                takeDamage(amount) {
                    this.hp -= amount;
                    this.hitTimer = 100;
                    if (this.hp <= 0) {
                        const humanPlayer = players[0];
                        audioManager.play('enemyDefeat');
                        audioManager.playMusic('game');
                        if (!this.isDemiBoss && !unlockedCharacters.includes(this.name)) {
                            unlockedCharacters.push(this.name);
                            saveGameState();
                            createFloatingText(`${this.name} débloqué!`, humanPlayer.x, humanPlayer.y, 'gold');
                        }
                        humanPlayer.isBonusLevelUp = true;
                        entities.xpOrbs.push(new XpOrb(this.x, this.y, this.xpValue, true));
                        humanPlayer.wallet += this.walletValue;
                        activeMiniBoss = null;

                        while (humanPlayer.xp >= humanPlayer.xpToNextLevel) {
                            humanPlayer.levelUp();
                        }
                    }
                }
            }
            
            class Projectile extends Entity {
                constructor(x, y, radius, { angle, speed, damage, lifespan, color = 'white', pierce = 0 }) {
                    super(x, y, radius);
                    Object.assign(this, { angle, speed, damage, lifespan, color, pierce });
                }
                update(dt) {
                    this.x += Math.cos(this.angle) * this.speed;
                    this.y += Math.sin(this.angle) * this.speed;
                    this.lifespan -= dt;
                }
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            class Rocket extends Projectile {
                constructor(x, y, owner) {
                    const options = { angle: 0, speed: 4, damage: 0, lifespan: 5000 };
                    super(x, y, 12, options);
                    this.owner = owner;
                    this.findNewTarget();
                }

                findNewTarget() {
                    this.target = entities.enemies.length > 0 ? entities.enemies.reduce((closest, enemy) => {
                        if (enemy.hp <= 0) return closest;
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        return dist < closest.dist ? { dist, enemy } : closest;
                    }, { dist: Infinity }).enemy : null;
                }

                update(dt) {
                    if (!this.target || this.target.hp <= 0 || !entities.enemies.includes(this.target)) {
                        this.findNewTarget();
                    }

                    if (this.target) {
                        this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    }
                    
                    super.update(dt);
                    if (this.lifespan <= 0) this.explode();
                }

                onHit() { this.explode(); }

                explode() {
                    if (this.lifespan <= 0) return;
                    audioManager.play('explosion');
                    this.lifespan = 0; 
                    const explosionRadius = 80 * this.owner.specialAreaMultiplier;
                    entities.particles.push(new Particle(this.x, this.y, 'cyan', explosionRadius, 400));
                    entities.enemies.forEach(enemy => {
                        if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < explosionRadius) {
                            enemy.takeDamage(100 * this.owner.globalDamageMultiplier * (1 + this.owner.permanentDamageBonus) * this.owner.levelDamageBonus * this.owner.specialDamageMultiplier);
                        }
                    });
                }

                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle + Math.PI / 2);
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('🚀', 0, 0);
                    ctx.restore();
                }
            }

            class XpOrb extends Entity {
                 constructor(x, y, value, isDouble = false) {
                    super(x, y, isDouble ? 7 : 5);
                    this.value = isDouble ? value * 2 : value;
                    this.color = isDouble ? 'var(--double-xp-color)' : 'var(--xp-color)';
                    this.isAttracted = false;
                }
                update(dt) {
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    if (this.isAttracted || Math.hypot(humanPlayer.x - this.x, humanPlayer.y - this.y) < humanPlayer.pickupRadius) {
                        this.isAttracted = true;
                        const angle = Math.atan2(humanPlayer.y - this.y, humanPlayer.x - this.x);
                        this.x += Math.cos(angle) * 8;
                        this.y += Math.sin(angle) * 8;
                    }
                }
                draw() {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue(this.color.replace(/var\(|\)/g, ''));
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            class HealthPickup extends Entity {
                constructor(x, y) {
                    super(x, y, 12);
                    this.lifespan = 30000;
                    this.healAmount = 25;
                    this.isAttracted = false;
                }
                update(dt) {
                    this.lifespan -= dt;
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    if (this.isAttracted || Math.hypot(humanPlayer.x - this.x, humanPlayer.y - this.y) < humanPlayer.pickupRadius) {
                        this.isAttracted = true;
                        const angle = Math.atan2(humanPlayer.y - this.y, humanPlayer.x - this.x);
                        this.x += Math.cos(angle) * 8;
                        this.y += Math.sin(angle) * 8;
                    }
                }
                draw() {
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('❤️', this.x, this.y);
                }
            }

            class FloatingText extends Entity {
                constructor(text, x, y, color) {
                    super(x,y,0);
                    this.text = text;
                    this.color = color;
                    this.lifespan = 1000;
                    this.initialLifespan = 1000;
                }
                update(dt) {
                    this.y -= 0.5;
                    this.lifespan -= dt;
                }
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.lifespan / this.initialLifespan;
                    ctx.fillStyle = this.color.startsWith('var') ? getComputedStyle(document.documentElement).getPropertyValue(this.color.replace(/var\(|\)/g, '')) : this.color;
                    ctx.font = 'bold 18px Poppins';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.text, this.x, this.y);
                    ctx.restore();
                }
            }
            
            class Particle extends Entity {
                 constructor(x, y, color, size, lifespan) {
                    super(x,y,0);
                    this.color = color;
                    this.size = size;
                    this.lifespan = lifespan;
                    this.initialLifespan = lifespan;
                }
                update(dt) {
                    this.lifespan -= dt;
                }
                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.lifespan / this.initialLifespan;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * (1 - (this.lifespan / this.initialLifespan)), 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            class Magnet extends Entity {
                constructor(x, y) {
                    super(x, y, 12);
                    this.lifespan = 30000;
                    this.isAttracted = false;
                }
                update(dt) {
                    this.lifespan -= dt;
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    if (this.isAttracted || Math.hypot(humanPlayer.x - this.x, humanPlayer.y - this.y) < humanPlayer.pickupRadius) {
                        this.isAttracted = true;
                        const angle = Math.atan2(humanPlayer.y - this.y, humanPlayer.x - this.x);
                        this.x += Math.cos(angle) * 8;
                        this.y += Math.sin(angle) * 8;
                    }
                }
                draw() {
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('🧲', this.x, this.y);
                }
            }

            class BonusUpgrade extends Entity {
                constructor(x, y) {
                    super(x, y, 12);
                    this.lifespan = 30000; // 30 secondes
                    this.isAttracted = false;
                }
                update(dt) {
                    this.lifespan -= dt;
                    const humanPlayer = players[0];
                    if (!humanPlayer) return;
                    if (this.isAttracted || Math.hypot(humanPlayer.x - this.x, humanPlayer.y - this.y) < humanPlayer.pickupRadius) {
                        this.isAttracted = true;
                        const angle = Math.atan2(humanPlayer.y - this.y, humanPlayer.x - this.x);
                        this.x += Math.cos(angle) * 8;
                        this.y += Math.sin(angle) * 8;
                    }
                }
                draw() {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 24px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('+', this.x, this.y);
                }
            }

            class Soldier extends Entity {
                constructor(x, y, owner, unitType, fusionLevel = 0) {
                    super(x, y, 10 + fusionLevel * 0.5);
                    this.owner = owner;
                    this.unitType = unitType;
                    this.fusionLevel = fusionLevel;
                    this.stats = armyUnitData[unitType];
                    this.color = getComputedStyle(document.documentElement).getPropertyValue(`--${this.stats.color}-color`);
                    this.fireTimer = this.getFireRate();
                    this.target = null;
                    // Propriétés pour le mouvement en formation
                    this.orbitAngle = owner.soldierOrbitAngle;
                    owner.soldierOrbitAngle += Math.PI / 4; // Espace les soldats
                    this.orbitRadius = 50 + (Math.random() * 20 - 10); // Un peu de variation
                    this.moveSpeed = 2.8; // Un peu plus lent que le joueur
                }

                getDamage() {
                    const skillBonus = multiplayerUpgrades.soldierDamage.level * multiplayerUpgrades.soldierDamage.bonus;
                    const fusionBonus = this.fusionLevel * 0.5; // +50% damage per fusion level
                    return this.stats.damage * (1 + skillBonus) * (1 + fusionBonus);
                }

                getFireRate() {
                    const bonus = multiplayerUpgrades.soldierFireRate.level * multiplayerUpgrades.soldierFireRate.bonus;
                    return this.stats.fireRate * (1 - bonus);
                }

                findTarget() {
                    const enemiesInQuadrant = entities.enemies.filter(e => e.quadrant === this.owner.playerId);
                    if (enemiesInQuadrant.length === 0) {
                        this.target = null;
                        return;
                    }

                    let closestDist = Infinity;
                    let closestEnemy = null;
                    enemiesInQuadrant.forEach(enemy => {
                        const dist = Math.hypot(this.x - enemy.x, this.y - enemy.y);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    });
                    this.target = closestEnemy;
                }

                update(dt) {
                    // --- Logique de mouvement pour suivre le joueur ---
                    const targetX = this.owner.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                    const targetY = this.owner.y + Math.sin(this.orbitAngle) * this.orbitRadius;

                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const dist = Math.hypot(dx, dy);

                    // Se déplace vers la position en orbite si n'est pas déjà assez proche
                    if (dist > 1) {
                        this.x += (dx / dist) * this.moveSpeed;
                        this.y += (dy / dist) * this.moveSpeed;
                    }
                    
                    // --- Logique de tir ---
                    this.fireTimer -= dt;

                    if (!this.target || this.target.hp <= 0) {
                        this.findTarget();
                    }

                    if (this.target && this.fireTimer <= 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const p_options = {
                            angle,
                            speed: this.stats.projectileSpeed,
                            damage: this.getDamage(),
                            lifespan: 1200,
                            color: this.color,
                            pierce: 0
                        };

                        if (this.unitType === 'rectangle') {
                            entities.projectiles.push(new Missile(this.x, this.y, 4, p_options));
                        } else {
                            entities.projectiles.push(new Projectile(this.x, this.y, 4, p_options));
                        }
                        
                        this.fireTimer = this.getFireRate();
                    }

                    // Garder le soldat dans le quadrant
                    const bounds = getQuadrantBoundaries(this.owner.playerId);
                    this.x = Math.max(bounds.minX + this.radius, Math.min(bounds.maxX - this.radius, this.x));
                    this.y = Math.max(bounds.minY + this.radius, Math.min(bounds.maxY - this.radius, this.y));
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 12px "Roboto Mono"';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.stats.shape, this.x, this.y + 1);

                    if (this.fusionLevel > 0) {
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 10px "Roboto Mono"';
                        ctx.fillText(this.fusionLevel, this.x, this.y + 1);
                    }
                }
            }
            
            // --- Classe Missile pour dégâts de zone ---
            class Missile extends Projectile {
                constructor(x, y, radius, options) {
                    super(x, y, radius, options);
                    this.explosionRadius = 40;
                }

                update(dt) {
                    super.update(dt);
                    // Si la durée de vie est écoulée, explose
                    if (this.lifespan <= 0) {
                        this.explode();
                    }
                }

                onHit() {
                    this.explode();
                }

                explode() {
                    if (this.lifespan <= -1) return; // Empêche les explosions multiples
                    
                    audioManager.play('explosion');
                    entities.particles.push(new Particle(this.x, this.y, this.color, this.explosionRadius, 300));
                    
                    entities.enemies.forEach(enemy => {
                        if (Math.hypot(this.x - enemy.x, this.y - enemy.y) < this.explosionRadius) {
                            enemy.takeDamage(this.damage);
                        }
                    });
                    
                    this.lifespan = -1; // Marque le projectile pour suppression
                }
            }

            class Pentagram extends Entity {
                constructor(x, y, owner) {
                    super(x, y, 60);
                    this.owner = owner;
                    this.lifespan = 20000; // Dure 20 secondes
                    this.rotation = 0;
                }

                update(dt) {
                    this.lifespan -= dt;
                    this.rotation += 0.01;
                }

                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    ctx.strokeStyle = 'rgba(255, 65, 77, 0.8)';
                    ctx.lineWidth = 3;

                    // Cercle extérieur
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Étoile
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (i * 2 * Math.PI / 5) - Math.PI / 2;
                        const x = Math.cos(angle) * this.radius;
                        const y = Math.sin(angle) * this.radius;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                }
            }


            // --- CLASSES D'ARMES ET LISTES D'AMÉLIORATIONS ---
            const progression = [1, 1.25, 1.5, 2.0, 3.0, 5.0]; // Niveaux 0-5.
            
            class Weapon {
                constructor(player, key) {
                    this.player = player;
                    this.key = key; // Pour retrouver les infos dans weaponList
                    this.level = 1; // Commence au niveau 1
                    this.timer = 0;
                    this.maxLevel = 5;
                }
                update(dt) {
                    this.timer -= dt;
                    if (this.timer <= 0) {
                        this.fire();
                        this.timer = this.getCooldown();
                    }
                }
                getCooldown() { 
                    const totalCooldownBonus = this.player.globalCooldownMultiplier * (1 - this.player.permanentCooldownBonus);
                    return this.baseCooldown * (1 / progression[this.level]) * totalCooldownBonus; 
                }
                getDamage() { 
                    const totalDamageBonus = this.player.globalDamageMultiplier * (1 + this.player.permanentDamageBonus) * this.player.levelDamageBonus;
                    return this.baseDamage * progression[this.level] * totalDamageBonus; 
                }
                fire() { /* Implémenté par les sous-classes */ }
                upgrade() { if(this.level < this.maxLevel) this.level++; }
            }

            class BuyGun extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 800;
                    this.baseDamage = 8;
                }
                fire() {
                    if (entities.enemies.length === 0) return;
                    
                    const enemiesInQuadrant = entities.enemies.filter(e => e.quadrant === this.player.playerId);
                    if (enemiesInQuadrant.length === 0) return;

                    audioManager.play('shoot');
                    let closestEnemy = enemiesInQuadrant.reduce((closest, enemy) => {
                        const dist = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);
                        return dist < closest.dist ? { dist, enemy } : closest;
                    }, { dist: Infinity }).enemy;

                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - this.player.y, closestEnemy.x - this.player.x);
                        const p_options = { angle, speed: 5, damage: this.getDamage(), lifespan: 1000 * this.player.projectileLifespanBonus, pierce: this.player.projectilePierceCount };
                        entities.projectiles.push(new Projectile(this.player.x, this.player.y, 4, p_options));
                    }
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente dégâts et cadence.`; }
            }
            
            class FomoGun extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 150;
                    this.baseDamage = 4;
                }
                fire() {
                     if (entities.enemies.length === 0) return;
                    audioManager.play('shoot');
                    let closestEnemy = entities.enemies.reduce((closest, enemy) => {
                        const dist = Math.hypot(this.player.x - enemy.x, this.player.y - enemy.y);
                        return dist < closest.dist ? { dist, enemy } : closest;
                    }, { dist: Infinity }).enemy;

                    if (closestEnemy) {
                        const angle = Math.atan2(closestEnemy.y - this.player.y, closestEnemy.x - this.player.x);
                        const p_options = { angle, speed: 7, damage: this.getDamage(), lifespan: 800 * this.player.projectileLifespanBonus, pierce: this.player.projectilePierceCount };
                        entities.projectiles.push(new Projectile(this.player.x, this.player.y, 3, p_options));
                    }
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente dégâts et cadence.`; }
            }

            class SpiralGun extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 400;
                    this.baseDamage = 5;
                    this.spiralAngle = 0;
                }
                fire() {
                    audioManager.play('shoot');
                    const totalProjectiles = 4;
                    for(let i=0; i<totalProjectiles; i++) {
                        const angle = (Math.PI*2 / totalProjectiles * i) + this.spiralAngle;
                        const p_options = { angle, speed: 3, damage: this.getDamage(), lifespan: 1500 * this.player.projectileLifespanBonus, pierce: this.player.projectilePierceCount };
                        entities.projectiles.push(new Projectile(this.player.x, this.player.y, 3, p_options));
                    }
                    this.spiralAngle += Math.PI / 16;
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente les dégâts.`; }
            }
            
            class LaserGun extends Weapon {
                constructor(player, key, angle, color) {
                    super(player, key);
                    this.baseCooldown = 4000;
                    this.baseDamage = 0.5; // Dégâts par tick
                    this.angle = angle;
                    this.color = color;
                    this.baseWidth = 10;
                }
                getWidth() { return this.baseWidth * progression[this.level]; }
                fire() {
                    audioManager.play('shoot');
                    const laser = new LaserBeam(this.player.x, this.player.y, this.angle, this.color, this.getWidth(), this.getDamage(), this.player);
                    entities.projectiles.push(laser);
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente largeur et dégâts.`; }
            }
            
            class PowerRangeGun extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 4000;
                    this.baseDamage = 0.5; // Dégâts par tick
                    this.color = 'orange';
                    this.baseWidth = 10;
                }
                getWidth() { return this.baseWidth * progression[this.level]; }
                fire() {
                    audioManager.play('shoot');
                    const damage = this.getDamage();
                    const width = this.getWidth();
                    // Laser vers la droite
                    entities.projectiles.push(new LaserBeam(this.player.x, this.player.y, 0, this.color, width, damage, this.player));
                    // Laser vers la gauche
                    entities.projectiles.push(new LaserBeam(this.player.x, this.player.y, Math.PI, this.color, width, damage, this.player));
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente largeur et dégâts.`; }
            }


            class LaserBeam extends Projectile {
                constructor(x, y, angle, color, width, damage, owner) {
                    super(x, y, 0, { angle, speed: 0, damage, lifespan: 200, color });
                    this.width = width;
                    this.owner = owner;
                }
                update(dt) {
                    super.update(dt);
                    if (!this.owner) { this.lifespan = 0; return; }
                    this.x = this.owner.x; // Le laser suit le joueur
                    this.y = this.owner.y;
                    // Appliquer les dégâts aux ennemis dans la zone
                    entities.enemies.forEach(e => {
                        const dx = e.x - this.x;
                        const dy = e.y - this.y;
                        const projectedDist = dx * Math.cos(this.angle) + dy * Math.sin(this.angle);
                        const perpDist = Math.abs(dx * Math.sin(this.angle) - dy * Math.cos(this.angle));
                        if(projectedDist > 0 && perpDist < this.width / 2) {
                            e.takeDamage(this.damage);
                        }
                    });
                }
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.globalAlpha = this.lifespan / 200;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(0, -this.width / 2, 2000, this.width);
                    ctx.restore();
                }
            }

            class MineLayer extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 5000;
                    this.baseDamage = 50;
                    this.baseRadius = 60;
                }
                getExplosionRadius() { return this.baseRadius * progression[this.level]; }
                fire() {
                    const mine = new Mine(this.player.x, this.player.y, this.getDamage(), this.getExplosionRadius());
                    entities.projectiles.push(mine);
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente dégâts et rayon d'explosion.`; }
            }

            class Mine extends Projectile {
                constructor(x, y, damage, explosionRadius) {
                    super(x, y, 8, { angle: 0, speed: 0, damage, lifespan: 2000, color: 'orange' });
                    this.explosionRadius = explosionRadius;
                }
                update(dt) {
                    this.lifespan -= dt;
                    if (this.lifespan <= 0) this.explode();
                }
                explode() {
                    if(this.lifespan > -1000) { // Pour éviter les explosions multiples
                        this.lifespan = -1001;
                        audioManager.play('explosion');
                        entities.particles.push(new Particle(this.x, this.y, 'orange', this.explosionRadius, 400));
                        entities.enemies.forEach(e => { 
                            if(Math.hypot(this.x - e.x, this.y - e.y) < this.explosionRadius) {
                                e.takeDamage(this.damage);
                            }
                        });
                    }
                }
            }
            
            class MagnetismAura extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.applyBonus(); // Applique le bonus initial
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    // Chaque niveau augmente le rayon en se basant sur le tableau de progression
                    this.player.pickupRadius = 50 * progression[this.level];
                }

                getUpgradeDescription() {
                    return `Niv ${this.level + 1}: Augmente le rayon d'attraction des orbes.`;
                }
            }

            class LiquidationWave extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.pierceLevels = [1, 2, 4, 8, 16];
                    this.applyBonus();
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    this.player.projectilePierceCount = this.pierceLevels[this.level - 1];
                }

                getUpgradeDescription() {
                    const nextPierce = this.level < this.maxLevel ? this.pierceLevels[this.level] : this.pierceLevels[this.level - 1];
                    return `Niv ${this.level + 1}: Les projectiles traversent ${nextPierce} ennemis.`;
                }
            }

            class Supertrader extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.bonuses = [
                        { damage: 1.10, cooldown: 0.90, area: 1.10 }, // Level 1
                        { damage: 1.20, cooldown: 0.80, area: 1.20 }, // Level 2
                        { damage: 1.30, cooldown: 0.70, area: 1.30 }, // Level 3
                        { damage: 1.50, cooldown: 0.60, area: 1.60 }, // Level 4
                        { damage: 2.00, cooldown: 0.50, area: 2.00 }, // Level 5
                    ];
                    this.applyBonus();
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    const bonus = this.bonuses[this.level - 1];
                    this.player.specialDamageMultiplier = bonus.damage;
                    this.player.specialCooldownMultiplier = bonus.cooldown;
                    this.player.specialAreaMultiplier = bonus.area;
                }

                getUpgradeDescription() {
                    if (this.level >= this.maxLevel) return "Niveau maximum atteint.";
                    const nextBonus = this.bonuses[this.level];
                    return `Niv ${this.level + 1}: +${Math.round((nextBonus.damage-1)*100)}% Dégâts, -${Math.round((1-nextBonus.cooldown)*100)}% Cooldown, +${Math.round((nextBonus.area-1)*100)}% Zone`;
                }
            }

            const weaponList = {
                buy: { name: "Buy", description: "Tire un projectile de base.", icon: '🔫', init: (p) => new BuyGun(p, 'buy') },
                fomo: { name: "Fomo", description: "Mitraillette rapide, dégâts réduits.", icon: '⚙️', init: (p) => new FomoGun(p, 'fomo') },
                spiral: { name: "Cercle Fibonacci", description: "Tirs en spirale.", icon: '🌀', init: (p) => new SpiralGun(p, 'spiral') },
                powerRange: { name: "Power Range", description: "Lasers horizontaux.", icon: '↔️', init: (p) => new PowerRangeGun(p, 'powerRange') },
                toTheMoon: { name: "To The Moon", description: "Laser vertical vers le haut.", icon: '🟢', init: (p) => new LaserGun(p, 'toTheMoon', -Math.PI/2, 'lime') },
                toTheHell: { name: "To The Hell", description: "Laser vertical vers le bas.", icon: '🔴', init: (p) => new LaserGun(p, 'toTheHell', Math.PI/2, 'red') },
                eclatement: { name: "Eclatement", description: "Pose des mines explosives.", icon: '💣', init: (p) => new MineLayer(p, 'eclatement') },
                magnetism: { name: "Aura Magnétique", description: "Augmente le rayon d'attraction des orbes.", icon: '🧲', init: (p) => new MagnetismAura(p, 'magnetism') },
                liquidation: { name: "Vague de Liquidations", description: "Les projectiles traversent les ennemis.", icon: '🌊', init: (p) => new LiquidationWave(p, 'liquidation') },
                supertrader: { name: "Supertrader", description: "Améliore la capacité spéciale.", icon: '💹', init: (p) => new Supertrader(p, 'supertrader') },
            };

            const passiveUpgrades = {
                damage: { 
                    name: "Puissance de Feu", icon: '💥',
                    apply: (p, bonus) => { p.globalDamageMultiplier *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                },
                range: { 
                    name: "Long HODL", icon: '🔭',
                    apply: (p, bonus) => { p.projectileLifespanBonus *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                },
                xpGain: { 
                    name: "Airdrop d'XP", icon: '🎓',
                    apply: (p, bonus) => { p.xpGainBonus *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                }
            };
            
            // --- Fonctions de sauvegarde et chargement ---
            function saveGameState() {
                const state = {
                    globalWallet,
                    unlockedCharacters,
                    permanentUpgrades
                };
                localStorage.setItem('cryptoSurvivorSave', JSON.stringify(state));
            }

            function loadGameState() {
                const savedState = localStorage.getItem('cryptoSurvivorSave');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    globalWallet = state.globalWallet || 0;
                    unlockedCharacters = state.unlockedCharacters || ['MVX'];
                    permanentUpgrades = state.permanentUpgrades || { damage: 0, health: 0, xpGain: 0, attackSpeed: 0 };
                }
            }

            function getPermanentBonuses() {
                const bonuses = { damage: 0, health: 0, xpGain: 0, attackSpeed: 0 };
                for (const key in permanentUpgrades) {
                    const level = permanentUpgrades[key];
                    if (level > 0) {
                        bonuses[key] = shopData[key].levels[level - 1].bonus;
                    }
                }
                return bonuses;
            }


            // --- FONCTIONS DE LOGIQUE DE JEU ---

            function init() {
                loadGameState(); // Charger les données au démarrage
                updateZoom();
                resizeCanvas();
                setupEventListeners();
                setupCharacterSelection();
            }
            
            function setupEventListeners() {
                window.addEventListener('resize', resizeCanvas);
                
                dom.buttons.startGame.addEventListener('click', async () => {
                    await audioManager.initialize(); // Initialise l'audio au premier clic
                    audioManager.playMusic('menu');
                    gameState = 'characterSelection';
                    setupCharacterSelection(); // Mettre à jour les persos débloqués
                    showScreen('characterSelection');
                });
                
                dom.buttons.multiplayer.addEventListener('click', () => {
                    showScreen('multiplayerMode');
                });

                dom.buttons.shop.addEventListener('click', async () => {
                     await audioManager.initialize();
                     audioManager.playMusic('menu');
                     displayShop();
                     showScreen('shop');
                });

                dom.buttons.backToMenu.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    showScreen('mainMenu');
                });
                
                dom.buttons.backFromCharSelect.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    showScreen('mainMenu');
                });
                
                dom.buttons.backToMenuFromLobby.addEventListener('click', () => {
                    showScreen('mapSelection');
                });
                
                dom.buttons.backToLobbyFromWaiting.addEventListener('click', () => {
                    showScreen('multiplayerLobby');
                });

                dom.buttons.backToMenuFromMapSelect.addEventListener('click', () => {
                    showScreen('multiplayerMode');
                });
                
                dom.buttons.backToMenuFromModeSelect.addEventListener('click', () => {
                    showScreen('mainMenu');
                });
                
                dom.buttons.armyAttack.addEventListener('click', () => {
                    showScreen('mapSelection');
                });

                dom.buttons.nextFromMapSelect.addEventListener('click', () => {
                    if (selectedMap) {
                        showScreen('multiplayerLobby');
                    }
                });
                
                document.querySelectorAll('.map-option').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.map-option').forEach(el => el.classList.remove('selected'));
                        e.currentTarget.classList.add('selected');
                        selectedMap = e.currentTarget.dataset.mapId;
                        dom.buttons.nextFromMapSelect.disabled = false;
                    });
                });


                dom.buttons.createGame.addEventListener('click', () => {
                    const gameId = Math.random().toString(36).substring(2, 8).toUpperCase();
                    dom.displays.gameIdDisplay.textContent = gameId;
                    showScreen('waitingRoom');
                });
                
                dom.buttons.startVsAi.addEventListener('click', () => {
                    startArmyAttack();
                });


                dom.buttons.restart.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    gameState = 'mainMenu';
                    showScreen('mainMenu');
                });

                dom.buttons.specialAbility.addEventListener('click', () => players[0]?.useSpecial());
                dom.buttons.mute.addEventListener('click', () => audioManager.toggleMute());
                dom.buttons.pause.addEventListener('click', togglePause);
                dom.buttons.resume.addEventListener('click', togglePause);
                
                dom.buttons.restartFromPause.addEventListener('click', () => {
                    togglePause();
                    if (gameMode === 'survivor') {
                        startGame(players[0].charType);
                    } else if (gameMode === 'armyAttack') {
                        startArmyAttack();
                    }
                });

                dom.buttons.mainMenuFromPause.addEventListener('click', () => {
                    showScreen('confirmQuit');
                });
                dom.buttons.confirmQuitYes.addEventListener('click', () => {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    showScreen('mainMenu');
                    gameState = 'mainMenu';
                    audioManager.playMusic('menu');
                });
                dom.buttons.confirmQuitNo.addEventListener('click', () => {
                    showScreen('pause');
                });
                dom.buttons.confirmUpgrade.addEventListener('click', () => {
                    selectedUpgrades.forEach(opt => applyUpgrade(opt));
                    selectedUpgrades = [];
                    
                    updateAllUI();
                    setTimeout(() => {
                        showScreen(null);
                        gameState = 'running';
                    }, 300);
                });

                dom.buttons.armyPanelToggle.addEventListener('click', () => {
                    dom.armyPanel.classList.toggle('collapsed');
                });

                dom.buttons.upgradePanelToggle.addEventListener('click', () => {
                    dom.upgradePanel.classList.toggle('collapsed');
                });

                document.querySelectorAll('.army-unit-button').forEach(button => {
                    button.addEventListener('click', () => {
                        const unitType = button.dataset.unit;
                        const cost = armyUnitData[unitType].cost;
                        const humanPlayer = players[0];

                        if (humanPlayer && humanPlayer.wallet >= cost) {
                            humanPlayer.wallet -= cost;
                            audioManager.play('purchase');

                            const spawnX = humanPlayer.x + (Math.random() - 0.5) * 40;
                            const spawnY = humanPlayer.y + (Math.random() - 0.5) * 40;

                            entities.soldiers.push(new Soldier(spawnX, spawnY, humanPlayer, unitType));
                            updateHud();
                            updateFusionUI();
                        } else {
                            console.log("Fonds insuffisants !");
                        }
                    });
                });

                // Écouteurs pour le nouvel écran de fin de partie
                document.getElementById('game-over-lobby-button').addEventListener('click', () => {
                    showScreen('multiplayerLobby'); // Retourne à l'écran du lobby
                    audioManager.playMusic('menu');
                });

                document.getElementById('game-over-quit-button').addEventListener('click', () => {
                    showScreen('mainMenu'); // Retourne au menu principal
                    audioManager.playMusic('menu');
                });

                document.getElementById('game-over-spectate-button').addEventListener('click', () => {
                    showScreen(null); // Cache juste l'écran de défaite pour regarder
                    gameState = 'spectating'; // Un nouvel état pour empêcher la boucle de s'arrêter
                });


                // Gestion des entrées
                window.addEventListener('keydown', (e) => inputManager.handleKey(e.key, true));
                window.addEventListener('keyup', (e) => inputManager.handleKey(e.key, false));
                canvas.addEventListener('touchstart', (e) => inputManager.joystick.start(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => inputManager.joystick.move(e), { passive: false });
                canvas.addEventListener('touchend', (e) => inputManager.joystick.end(e));
                canvas.addEventListener('touchcancel', (e) => inputManager.joystick.end(e));
            }

            function updateZoom() {
                if (window.innerWidth < 768) {
                    zoomFactor = 1.5; // Dézoomer de 50% sur mobile
                } else {
                    zoomFactor = 1.0; // Zoom par défaut sur bureau
                }
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                updateZoom();
            }

            function togglePause() {
                if (gameState === 'running') {
                    gameState = 'paused';
                    showScreen('pause');
                } else if (gameState === 'paused') {
                    gameState = 'running';
                    lastTime = performance.now(); // Pour éviter un saut de temps
                    showScreen(null);
                }
            }
            
            function startArmyAttack() {
                gameMode = 'armyAttack';
                resetGameState('MVX'); 
                
                showScreen(null); // Hide all menus
                dom.gameHud.classList.remove('hidden'); 
                dom.armyPanel.classList.remove('hidden');
                dom.upgradePanel.classList.remove('hidden');
                setupMultiplayerUpgrades();
                updateFusionUI();
                
                gameState = 'running';
                lastTime = performance.now();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function startGame(charType) {
                gameMode = 'survivor';
                resetGameState(charType);
                audioManager.playMusic('game');

                showScreen(null);
                dom.gameHud.classList.remove('hidden');
                dom.buttons.specialAbility.classList.remove('hidden');
                dom.displays.passiveUpgrades.classList.remove('hidden');
                dom.displays.weaponUI.classList.remove('hidden');
                dom.armyPanel.classList.add('hidden');
                dom.upgradePanel.classList.add('hidden');
                
                updateAllUI();
                
                gameState = 'running';
                lastTime = performance.now();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function endGame(winner = null) {
                gameState = 'gameOver';
                audioManager.playMusic('gameOver');
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            
                const humanPlayer = players[0];
                const gameOverTitle = document.getElementById('game-over-title');
                const survivorStats = document.getElementById('survivor-stats');
                const restartButton = document.getElementById('restart-button');
                const lobbyButton = document.getElementById('game-over-lobby-button');
                const spectateButton = document.getElementById('game-over-spectate-button');
                const quitButton = document.getElementById('game-over-quit-button');
                
                // Cache tous les boutons par défaut
                restartButton.classList.add('hidden');
                lobbyButton.classList.add('hidden');
                spectateButton.classList.add('hidden');
                quitButton.classList.add('hidden');
            
                if (gameMode === 'survivor') {
                    globalWallet += humanPlayer.wallet;
                    saveGameState();
                    
                    gameOverTitle.textContent = "LIQUIDATED!";
                    survivorStats.style.display = 'block';
                    document.getElementById('final-time').textContent = formatTime(timers.game);
                    document.getElementById('final-level').textContent = humanPlayer.level;
                    document.getElementById('final-gain').textContent = humanPlayer.wallet;
                    restartButton.classList.remove('hidden');
            
                } else if (gameMode === 'armyAttack') {
                    survivorStats.style.display = 'none'; // On cache les stats de survie
                    
                    if (humanPlayer.hp <= 0) { // Le joueur a perdu
                        gameOverTitle.textContent = "VOUS AVEZ PERDU !";
                        lobbyButton.classList.remove('hidden');
                        quitButton.classList.remove('hidden');
            
                        const alivePlayers = players.filter(p => p.hp > 0).length;
                        if (alivePlayers >= 2) { // S'il reste au moins 2 autres joueurs
                            spectateButton.classList.remove('hidden');
                        }
            
                    } else if (winner && winner.playerId === 1) { // Le joueur a gagné
                        gameOverTitle.textContent = "VICTOIRE !";
                        lobbyButton.classList.remove('hidden');
                        quitButton.classList.remove('hidden');
                    }
                }
                
                dom.gameHud.classList.add('hidden');
                dom.buttons.specialAbility.classList.add('hidden');
                dom.displays.passiveUpgrades.classList.add('hidden');
                dom.displays.weaponUI.classList.add('hidden');
                dom.armyPanel.classList.add('hidden');
                dom.upgradePanel.classList.add('hidden');
                
                showScreen('gameOver');
            }
            
            function resetGameState(charType) {
                players = [];
                const humanPlayer = new Player(charType, 1);
                players.push(humanPlayer);

                if (gameMode === 'survivor') {
                    humanPlayer.x = WORLD_WIDTH / 2;
                    humanPlayer.y = WORLD_HEIGHT / 2;
                    humanPlayer.weapons.push(weaponList.buy.init(humanPlayer));
                } else if (gameMode === 'armyAttack') {
                    // Reset multiplayer upgrades for the new game
                    Object.keys(multiplayerUpgrades).forEach(key => {
                        multiplayerUpgrades[key].level = 0;
                    });

                    if (selectedMap === 'quadrant_4p') {
                        const positions = [
                            { x: WORLD_WIDTH * 0.25, y: WORLD_HEIGHT * 0.25 }, // P1
                            { x: WORLD_WIDTH * 0.75, y: WORLD_HEIGHT * 0.25 }, // P2
                            { x: WORLD_WIDTH * 0.25, y: WORLD_HEIGHT * 0.75 }, // P3
                            { x: WORLD_WIDTH * 0.75, y: WORLD_HEIGHT * 0.75 }  // P4
                        ];
                        
                        players[0].x = positions[0].x;
                        players[0].y = positions[0].y;
                        players[0].weapons.push(weaponList.buy.init(players[0]));

                        const botChars = ['AVAX', 'SOL', 'ETH'];
                        for (let i = 0; i < 3; i++) {
                            const bot = new BotPlayer(botChars[i], i + 2);
                            bot.x = positions[i + 1].x;
                            bot.y = positions[i + 1].y;
                            bot.weapons.push(weaponList.buy.init(bot));
                            players.push(bot);
                        }
                    } else if (selectedMap === 'vertical_2p') {
                          const positions = [
                            { x: WORLD_WIDTH * 0.5, y: WORLD_HEIGHT * 0.25 }, // P1
                            { x: WORLD_WIDTH * 0.5, y: WORLD_HEIGHT * 0.75 }, // P2
                        ];
                        players[0].x = positions[0].x;
                        players[0].y = positions[0].y;
                        players[0].weapons.push(weaponList.buy.init(players[0]));
                        const bot = new BotPlayer('AVAX', 2);
                        bot.x = positions[1].x;
                        bot.y = positions[1].y;
                        bot.weapons.push(weaponList.buy.init(bot));
                        players.push(bot);
                    }
                }
                
                Object.keys(entities).forEach(key => entities[key] = []);
                Object.keys(timers).forEach(key => timers[key] = 0);
                armyAttackTimers = { wave: 0, waveCount: 0 };
                
                activeMiniBoss = null;
                if (gameMode === 'survivor') {
                    spawnBonusUpgrade();
                }
            }

            function gameLoop(timestamp) {
                if (gameState !== 'running' && gameState !== 'spectating') {
                    if (gameState === 'levelUp' || gameState === 'paused') {
                        draw(); // Continue drawing for background effect
                    }
                    animationFrameId = requestAnimationFrame(gameLoop);
                    return;
                };

                const dt = timestamp - lastTime;
                lastTime = timestamp;

                update(dt);
                draw();
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function update(dt) {
                if (gameMode === 'survivor') {
                    updateSurvivor(dt);
                } else if (gameMode === 'armyAttack') {
                    updateArmyAttack(dt);
                }
            }

            function draw() {
                const humanPlayer = players[0];
                if (!humanPlayer && gameState !== 'mainMenu' && gameState !== 'shop') {
                     ctx.clearRect(0, 0, canvas.width, canvas.height);
                     return;
                }

                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Appliquer le zoom et la caméra
                ctx.scale(1 / zoomFactor, 1 / zoomFactor);
                if(humanPlayer) {
                   ctx.translate(-camera.x, -camera.y);
                }

                drawWorldBackground();
                
                if (gameMode === 'armyAttack') {
                    drawArmyAttackElements();
                } 
                
                Object.values(entities).flat().forEach(e => e.draw());
                
                players.forEach(p => {
                    if (p.hp > 0) p.draw();
                });

                ctx.restore();
                
                drawMinimap();
            }

            function updateArmyAttack(dt) {
                timers.game += dt / 1000;
                armyAttackTimers.wave += dt;

                if (armyAttackTimers.wave > TOWER_WAVE_INTERVAL) {
                    spawnArmyWave();
                    armyAttackTimers.wave = 0; 
                }

                players.forEach(p => p.update(dt));
                Object.values(entities).flat().forEach(e => e.update(dt));
                updatePentagrams(dt);

                updateCamera();
                handleCollisions();

                Object.keys(entities).forEach(key => {
                    entities[key] = entities[key].filter(e => e.lifespan === undefined || e.lifespan > 0);
                });
                entities.enemies = entities.enemies.filter(e => e.hp > 0);

                updateHud();
                updateFusionUI(); // Mettre à jour les options de fusion
                updatePentagramUI();

                // Check for winner
                const alivePlayers = players.filter(p => p.hp > 0);
                if (alivePlayers.length <= 1 && gameState === 'running') {
                    endGame(alivePlayers[0]);
                }
            }

            function drawArmyAttackElements() {
                ctx.fillStyle = 'rgb(17, 34, 64)';
                if (selectedMap === 'quadrant_4p') {
                    ctx.fillRect(WORLD_WIDTH / 2 - 10, 0, 20, WORLD_HEIGHT);
                    ctx.fillRect(0, WORLD_HEIGHT / 2 - 10, WORLD_WIDTH, 20);
                } else if (selectedMap === 'vertical_2p') {
                    ctx.fillRect(0, WORLD_HEIGHT / 2 - 10, WORLD_WIDTH, 20);
                }
            }

            function updateSurvivor(dt) {
                const humanPlayer = players[0];
                timers.game += dt / 1000;
                timers.enemySpawn += dt;
                timers.magnetSpawn += dt;
                timers.healthSpawn += dt;
                
                if (timers.enemySpawn > ENEMY_BASE_SPAWN_RATE) {
                    spawnEnemyWave();
                    timers.enemySpawn = 0;
                }
                if (timers.magnetSpawn > MAGNET_SPAWN_RATE) {
                    entities.magnets.push(new Magnet(camera.x + Math.random() * canvas.width, camera.y + Math.random() * canvas.height));
                    timers.magnetSpawn = 0;
                }
                if (timers.healthSpawn > HEALTH_SPAWN_RATE) {
                    entities.healthPickups.push(new HealthPickup(camera.x + Math.random() * canvas.width, camera.y + Math.random() * canvas.height));
                    timers.healthSpawn = 0;
                }

                humanPlayer.update(dt);
                updateCamera();
                Object.values(entities).flat().forEach(e => e.update(dt));

                handleCollisions();
                
                Object.keys(entities).forEach(key => {
                    entities[key] = entities[key].filter(e => e.lifespan === undefined || e.lifespan > 0);
                });
                entities.enemies = entities.enemies.filter(e => e.hp > 0);

                updateHud();
            }

            function updateCamera() {
                const humanPlayer = players[0];
                if (!humanPlayer) return;

                const viewWidth = canvas.width * zoomFactor;
                const viewHeight = canvas.height * zoomFactor;

                camera.x = humanPlayer.x - viewWidth / 2;
                camera.y = humanPlayer.y - viewHeight / 2;
                
                const bounds = getQuadrantBoundaries(humanPlayer.playerId);
                camera.x = Math.max(bounds.minX, Math.min(bounds.maxX - viewWidth, camera.x));
                camera.y = Math.max(bounds.minY, Math.min(bounds.maxY - viewHeight, camera.y));
            }

            function drawMinimap() {
                if (players.length === 0) return;

                const minimap = dom.displays.minimapCanvas;
                const minimapCtx = minimap.getContext('2d');
                const mapWidth = minimap.width;
                const mapHeight = minimap.height;

                minimapCtx.fillStyle = 'rgba(17, 34, 64, 0.8)';
                minimapCtx.fillRect(0, 0, mapWidth, mapHeight);

                minimapCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
                minimapCtx.lineWidth = 1;
                minimapCtx.beginPath();
</body>
</html>
