<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Crypto Survivor: To The Moon</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&family=Roboto+Mono:wght@700&display=swap" rel="stylesheet">
    
    <!-- Ajout de la bibliothèque Tone.js pour l'audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>

    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Menu Principal -->
    <div id="main-menu-screen" class="screen active">
        <div class="screen-content">
            <h1>Crypto Survivor</h1>
            <div class="menu-buttons">
                <button id="start-game-button" class="action-button">Survivor Mode</button>
                <button id="multiplayer-button" class="action-button">Multijoueur</button>
                <button id="shop-button" class="action-button">Boutique</button>
                <button id="options-button" class="action-button" disabled>Options</button>
            </div>
        </div>
    </div>

    <!-- Écran de Boutique -->
    <div id="shop-screen" class="screen">
        <div class="screen-content">
            <h1>Boutique</h1>
            <p>Améliorations Permanentes</p>
            <div id="shop-wallet-display">0</div>
            <div id="shop-items-container">
                            </div>
            <button id="back-to-menu-button" class="action-button">Retour</button>
        </div>
    </div>

    <!-- Écran de sélection du personnage -->
    <div id="character-selection-screen" class="screen">
        <div class="screen-content">
            <h1>Crypto Survivor</h1>
            <p>Choisissez votre Crypto</p>
            <div class="character-choices" id="character-choices-container">
                            </div>
            <button id="back-to-menu-from-char-select-button" class="action-button">Retour</button>
        </div>
    </div>

    <!-- Écran de Sélection de Mode Multijoueur -->
    <div id="multiplayer-mode-screen" class="screen">
        <div class="screen-content">
            <h2>Choisissez un mode</h2>
            <div class="menu-buttons">
                <button id="army-attack-button" class="action-button">Army Attaque</button>
                <button class="action-button" disabled>Tower Defence</button>
                <button class="action-button" disabled>Coming Soon</button>
                <button class="action-button" disabled>Coming Soon</button>
            </div>
            <button id="back-to-menu-from-mode-select-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
        </div>
    </div>

    <!-- Écran de Sélection de Carte -->
    <div id="map-selection-screen" class="screen">
        <div class="screen-content">
            <h2>Choisissez une carte</h2>
            <div class="map-choices">
                <div class="map-option" data-map-id="quadrant_4p">
                    <div class="map-preview">
                        <div class="map-preview-line-v"></div>
                        <div class="map-preview-line-h"></div>
                    </div>
                    <strong>Arène 4 Joueurs</strong>
                    <span>4 Joueurs</span>
                </div>
                 <div class="map-option" data-map-id="vertical_2p">
                    <div class="map-preview">
                        <div class="map-preview-line-h"></div>
                    </div>
                    <strong>Duel Vertical</strong>
                    <span>2 Joueurs</span>
                </div>
            </div>
            <div class="menu-buttons">
                 <button id="next-from-map-select-button" class="action-button" disabled>Suivant</button>
                 <button id="back-to-menu-from-map-select-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
            </div>
        </div>
    </div>
    
    <!-- Écran du Lobby Multijoueur -->
    <div id="multiplayer-lobby-screen" class="screen">
        <div class="screen-content">
            <h2>Multijoueur</h2>
            <div class="form-group">
                <label for="player-name-input">Pseudo</label>
                <input type="text" id="player-name-input" placeholder="Votre pseudo..." maxlength="12">
            </div>
            <div class="form-group">
                <label for="game-id-input">ID de la partie</label>
                <input type="text" id="game-id-input" placeholder="Entrez un ID pour rejoindre...">
            </div>
            <button id="join-game-button" class="action-button" disabled>Rejoindre</button>
            <button id="create-game-button" class="action-button">Créer une partie</button>
            <button id="back-to-menu-from-lobby-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
        </div>
    </div>

    <!-- Écran du Salon d'attente -->
    <div id="waiting-room-screen" class="screen">
        <div class="screen-content">
            <h2>Salon d'attente</h2>
            <p id="waiting-room-info">ID de la partie : <span id="game-id-display"></span></p>
            <h3>Joueurs (1/4)</h3>
            <ul id="player-list">
                                <li>Votre Pseudo (Hôte)</li>
            </ul>
            <div class="menu-buttons">
                <button id="start-vs-ai-button" class="action-button">Jouer contre l'IA</button>
                <button id="start-multiplayer-game-button" class="action-button" disabled>Lancer la partie (2+ Joueurs)</button>
                <button id="back-to-lobby-from-waiting-button" class="action-button" style="background-color: var(--disabled-color);">Retour</button>
            </div>
        </div>
    </div>


    <!-- Écran de Pause -->
    <div id="pause-screen" class="screen">
        <div class="screen-content">
            <h2>PAUSE</h2>
            <div class="menu-buttons">
                <button id="resume-button" class="action-button">Continuer</button>
                <button id="restart-from-pause-button" class="action-button">Recommencer</button>
                <button id="main-menu-from-pause-button" class="action-button">Menu Principal</button>
            </div>
        </div>
    </div>

    <!-- Écran de Confirmation pour Quitter -->
    <div id="confirm-quit-screen" class="screen">
        <div class="screen-content">
            <h2>Quitter la partie ?</h2>
            <p>Votre progression dans cette partie sera perdue.</p>
            <div style="display: flex; justify-content: center; gap: 20px;">
                <button id="confirm-quit-yes-button" class="action-button">Oui</button>
                <button id="confirm-quit-no-button" class="action-button" style="background-color: var(--disabled-color);">Non</button>
            </div>
        </div>
    </div>

    <!-- Interface du jeu (HUD) -->
    <div id="game-hud" class="hidden">
        <div id="hud-left-column">
            <div id="stats-container">
                <div id="stats-left">
                    <div>LVL: <span id="player-level">1</span></div>
                    <div>$<span class="mvx-logo-inline">X</span> <span id="player-wallet">0</span></div>
                </div>
                <div id="game-timer">00:00</div>
            </div>
            <div id="top-health-bar">
                <div id="top-health-bar-fill"></div>
                <span id="top-health-bar-text">100 / 100</span>
            </div>
            <div id="xp-bar-container">
                <div id="xp-bar"></div>
                <span id="xp-bar-text">0 / 10</span>
            </div>
        </div>
        <div id="hud-right-column">
            <canvas id="minimap-canvas" width="80" height="80"></canvas>
            <button id="pause-button" class="game-ui-button">||</button>
        </div>
    </div>
    <div id="bonus-timer" class="hidden"></div>

    <!-- Panneau d'Améliorations (Gauche) -->
    <div id="upgrade-panel" class="side-panel hidden">
        <button id="upgrade-panel-toggle" class="side-panel-toggle"><span>◀</span></button>
        <div id="skill-points-display">Points: 0</div>
        <div id="multiplayer-upgrades-container">
                    </div>
    </div>

    <!-- Panneau d'Achat d'Armée (Droite) -->
    <div id="army-purchase-panel" class="side-panel hidden">
        <button id="army-panel-toggle" class="side-panel-toggle"><span>▶</span></button>
        <h3>Construire Armée</h3>
        <div class="army-unit-button" data-unit="triangle">
            <span class="unit-shape">▲</span>
            <div class="unit-info">
                <span class="unit-name">Mitrailleur</span>
                <span class="unit-cost">50 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <div class="army-unit-button" data-unit="square">
            <span class="unit-shape">■</span>
            <div class="unit-info">
                <span class="unit-name">Artilleur</span>
                <span class="unit-cost">100 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <div class="army-unit-button" data-unit="rectangle">
            <span class="unit-shape">▬</span>
            <div class="unit-info">
                <span class="unit-name">Lance-Missiles</span>
                <span class="unit-cost">150 $<span class="mvx-logo-inline">X</span></span>
            </div>
        </div>
        <h3 id="fusion-title" class="hidden">Fusionner</h3>
        <div id="fusion-options-container">
                      </div>
    </div>


    <!-- Écran de montée de niveau -->
    <div id="level-up-screen" class="screen">
        <div class="screen-content">
            <h2 id="level-up-title">LEVEL UP!</h2>
            <p id="level-up-subtitle">Choisissez une seule amélioration :</p>
            <div id="level-up-options"></div>
            <button id="confirm-upgrade-button" class="action-button hidden">Confirmer</button>
        </div>
    </div>

    <!-- Écran de fin de partie -->
    <div id="game-over-screen" class="screen">
        <div class="screen-content">
            <h2 id="game-over-title">LIQUIDATED!</h2>
            <div id="survivor-stats">
                <p>Vous avez survécu <span id="final-time">00:00</span>.</p>
                <p>Niveau final : <span id="final-level">1</span></p>
                <p>Gains : <span id="final-gain">0</span> $<span class="mvx-logo-inline">X</span></p>
            </div>
            <div id="game-over-buttons" class="menu-buttons">
                                <button id="restart-button" class="action-button">Menu Principal</button>
                                <button id="game-over-lobby-button" class="action-button hidden">Lobby</button>
                <button id="game-over-spectate-button" class="action-button hidden">Mode Spectateur</button>
                <button id="game-over-quit-button" class="action-button hidden">Menu Principal</button>
            </div>
        </div>
    </div>
    
    <!-- Affichages UI en jeu -->
    <div id="passive-upgrades-display" class="hidden"></div>
    <div id="weapon-display-ui" class="hidden"></div>

    <!-- Éléments du jeu -->
    <canvas id="game-canvas"></canvas>
    <div id="joystick-container"><div id="joystick-handle"></div></div>
    <button id="special-ability-button" class="hidden">🚀</button>
    <button id="mute-button" class="game-ui-button">🎵</button>
    
    <!-- Barre de chargement du Pentagramme -->
    <div id="pentagram-charge-container" class="hidden">
        <div id="pentagram-charge-bar"></div>
        <span id="pentagram-charge-text">Invocation...</span>
    </div>

    <!-- Scripts du jeu -->
    <script src="js/constants.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/audio.js"></script>
    <script src="js/save.js"></script>
    <script src="js/entities.js"></script>
    <script src="js/weapons.js"></script>
    <script src="js/ui.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
                    super(x, y, 0, { angle, speed: 0, damage, lifespan: 200, color });
                    this.width = width;
                    this.owner = owner;
                }
                update(dt) {
                    super.update(dt);
                    if (!this.owner) { this.lifespan = 0; return; }
                    this.x = this.owner.x; // Le laser suit le joueur
                    this.y = this.owner.y;
                    // Appliquer les dégâts aux ennemis dans la zone
                    entities.enemies.forEach(e => {
                        const dx = e.x - this.x;
                        const dy = e.y - this.y;
                        const projectedDist = dx * Math.cos(this.angle) + dy * Math.sin(this.angle);
                        const perpDist = Math.abs(dx * Math.sin(this.angle) - dy * Math.cos(this.angle));
                        if(projectedDist > 0 && perpDist < this.width / 2) {
                            e.takeDamage(this.damage);
                        }
                    });
                }
                draw() {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    ctx.globalAlpha = this.lifespan / 200;
                    ctx.fillStyle = this.color;
                    ctx.fillRect(0, -this.width / 2, 2000, this.width);
                    ctx.restore();
                }
            }

            class MineLayer extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 5000;
                    this.baseDamage = 50;
                    this.baseRadius = 60;
                }
                getExplosionRadius() { return this.baseRadius * progression[this.level]; }
                fire() {
                    const mine = new Mine(this.player.x, this.player.y, this.getDamage(), this.getExplosionRadius());
                    entities.projectiles.push(mine);
                }
                getUpgradeDescription() { return `Niv ${this.level + 1}: Augmente dégâts et rayon d'explosion.`; }
            }

            class Mine extends Projectile {
                constructor(x, y, damage, explosionRadius) {
                    super(x, y, 8, { angle: 0, speed: 0, damage, lifespan: 2000, color: 'orange' });
                    this.explosionRadius = explosionRadius;
                }
                update(dt) {
                    this.lifespan -= dt;
                    if (this.lifespan <= 0) this.explode();
                }
                explode() {
                    if(this.lifespan > -1000) { // Pour éviter les explosions multiples
                        this.lifespan = -1001;
                        audioManager.play('explosion');
                        entities.particles.push(new Particle(this.x, this.y, 'orange', this.explosionRadius, 400));
                        entities.enemies.forEach(e => { 
                            if(Math.hypot(this.x - e.x, this.y - e.y) < this.explosionRadius) {
                                e.takeDamage(this.damage);
                            }
                        });
                    }
                }
            }
            
            class MagnetismAura extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.applyBonus(); // Applique le bonus initial
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    // Chaque niveau augmente le rayon en se basant sur le tableau de progression
                    this.player.pickupRadius = 50 * progression[this.level];
                }

                getUpgradeDescription() {
                    return `Niv ${this.level + 1}: Augmente le rayon d'attraction des orbes.`;
                }
            }

            class LiquidationWave extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.pierceLevels = [1, 2, 4, 8, 16];
                    this.applyBonus();
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    this.player.projectilePierceCount = this.pierceLevels[this.level - 1];
                }

                getUpgradeDescription() {
                    const nextPierce = this.level < this.maxLevel ? this.pierceLevels[this.level] : this.pierceLevels[this.level - 1];
                    return `Niv ${this.level + 1}: Les projectiles traversent ${nextPierce} ennemis.`;
                }
            }

            class Supertrader extends Weapon {
                constructor(player, key) {
                    super(player, key);
                    this.baseCooldown = 9999999; // Ne tire jamais
                    this.baseDamage = 0;
                    this.bonuses = [
                        { damage: 1.10, cooldown: 0.90, area: 1.10 }, // Level 1
                        { damage: 1.20, cooldown: 0.80, area: 1.20 }, // Level 2
                        { damage: 1.30, cooldown: 0.70, area: 1.30 }, // Level 3
                        { damage: 1.50, cooldown: 0.60, area: 1.60 }, // Level 4
                        { damage: 2.00, cooldown: 0.50, area: 2.00 }, // Level 5
                    ];
                    this.applyBonus();
                }

                fire() { /* Ne fait rien */ }

                upgrade() {
                    if (this.level < this.maxLevel) {
                        this.level++;
                        this.applyBonus();
                    }
                }

                applyBonus() {
                    const bonus = this.bonuses[this.level - 1];
                    this.player.specialDamageMultiplier = bonus.damage;
                    this.player.specialCooldownMultiplier = bonus.cooldown;
                    this.player.specialAreaMultiplier = bonus.area;
                }

                getUpgradeDescription() {
                    if (this.level >= this.maxLevel) return "Niveau maximum atteint.";
                    const nextBonus = this.bonuses[this.level];
                    return `Niv ${this.level + 1}: +${Math.round((nextBonus.damage-1)*100)}% Dégâts, -${Math.round((1-nextBonus.cooldown)*100)}% Cooldown, +${Math.round((nextBonus.area-1)*100)}% Zone`;
                }
            }

            const weaponList = {
                buy: { name: "Buy", description: "Tire un projectile de base.", icon: '🔫', init: (p) => new BuyGun(p, 'buy') },
                fomo: { name: "Fomo", description: "Mitraillette rapide, dégâts réduits.", icon: '⚙️', init: (p) => new FomoGun(p, 'fomo') },
                spiral: { name: "Cercle Fibonacci", description: "Tirs en spirale.", icon: '🌀', init: (p) => new SpiralGun(p, 'spiral') },
                powerRange: { name: "Power Range", description: "Lasers horizontaux.", icon: '↔️', init: (p) => new PowerRangeGun(p, 'powerRange') },
                toTheMoon: { name: "To The Moon", description: "Laser vertical vers le haut.", icon: '🟢', init: (p) => new LaserGun(p, 'toTheMoon', -Math.PI/2, 'lime') },
                toTheHell: { name: "To The Hell", description: "Laser vertical vers le bas.", icon: '🔴', init: (p) => new LaserGun(p, 'toTheHell', Math.PI/2, 'red') },
                eclatement: { name: "Eclatement", description: "Pose des mines explosives.", icon: '💣', init: (p) => new MineLayer(p, 'eclatement') },
                magnetism: { name: "Aura Magnétique", description: "Augmente le rayon d'attraction des orbes.", icon: '🧲', init: (p) => new MagnetismAura(p, 'magnetism') },
                liquidation: { name: "Vague de Liquidations", description: "Les projectiles traversent les ennemis.", icon: '🌊', init: (p) => new LiquidationWave(p, 'liquidation') },
                supertrader: { name: "Supertrader", description: "Améliore la capacité spéciale.", icon: '💹', init: (p) => new Supertrader(p, 'supertrader') },
            };

            const passiveUpgrades = {
                damage: { 
                    name: "Puissance de Feu", icon: '💥',
                    apply: (p, bonus) => { p.globalDamageMultiplier *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                },
                range: { 
                    name: "Long HODL", icon: '🔭',
                    apply: (p, bonus) => { p.projectileLifespanBonus *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                },
                xpGain: { 
                    name: "Airdrop d'XP", icon: '🎓',
                    apply: (p, bonus) => { p.xpGainBonus *= (1 + bonus); },
                    levels: [
                        { level: 1, bonus: 0.15, weight: 10 }, { level: 2, bonus: 0.30, weight: 7 },
                        { level: 3, bonus: 0.60, weight: 4 }, { level: 4, bonus: 1.20, weight: 2 },
                        { level: 5, bonus: 2.40, weight: 1 }
                    ]
                }
            };
            
            // --- Fonctions de sauvegarde et chargement ---
            function saveGameState() {
                const state = {
                    globalWallet,
                    unlockedCharacters,
                    permanentUpgrades
                };
                localStorage.setItem('cryptoSurvivorSave', JSON.stringify(state));
            }

            function loadGameState() {
                const savedState = localStorage.getItem('cryptoSurvivorSave');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    globalWallet = state.globalWallet || 0;
                    unlockedCharacters = state.unlockedCharacters || ['MVX'];
                    permanentUpgrades = state.permanentUpgrades || { damage: 0, health: 0, xpGain: 0, attackSpeed: 0 };
                }
            }

            function getPermanentBonuses() {
                const bonuses = { damage: 0, health: 0, xpGain: 0, attackSpeed: 0 };
                for (const key in permanentUpgrades) {
                    const level = permanentUpgrades[key];
                    if (level > 0) {
                        bonuses[key] = shopData[key].levels[level - 1].bonus;
                    }
                }
                return bonuses;
            }


            // --- FONCTIONS DE LOGIQUE DE JEU ---

            function init() {
                loadGameState(); // Charger les données au démarrage
                updateZoom();
                resizeCanvas();
                setupEventListeners();
                setupCharacterSelection();
            }
            
            function setupEventListeners() {
                window.addEventListener('resize', resizeCanvas);
                
                dom.buttons.startGame.addEventListener('click', async () => {
                    await audioManager.initialize(); // Initialise l'audio au premier clic
                    audioManager.playMusic('menu');
                    gameState = 'characterSelection';
                    setupCharacterSelection(); // Mettre à jour les persos débloqués
                    showScreen('characterSelection');
                });
                
                dom.buttons.multiplayer.addEventListener('click', () => {
                    showScreen('multiplayerMode');
                });

                dom.buttons.shop.addEventListener('click', async () => {
                     await audioManager.initialize();
                     audioManager.playMusic('menu');
                     displayShop();
                     showScreen('shop');
                });

                dom.buttons.backToMenu.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    showScreen('mainMenu');
                });
                
                dom.buttons.backFromCharSelect.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    showScreen('mainMenu');
                });
                
                dom.buttons.backToMenuFromLobby.addEventListener('click', () => {
                    showScreen('mapSelection');
                });
                
                dom.buttons.backToLobbyFromWaiting.addEventListener('click', () => {
                    showScreen('multiplayerLobby');
                });

                dom.buttons.backToMenuFromMapSelect.addEventListener('click', () => {
                    showScreen('multiplayerMode');
                });
                
                dom.buttons.backToMenuFromModeSelect.addEventListener('click', () => {
                    showScreen('mainMenu');
                });
                
                dom.buttons.armyAttack.addEventListener('click', () => {
                    showScreen('mapSelection');
                });

                dom.buttons.nextFromMapSelect.addEventListener('click', () => {
                    if (selectedMap) {
                        showScreen('multiplayerLobby');
                    }
                });
                
                document.querySelectorAll('.map-option').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.map-option').forEach(el => el.classList.remove('selected'));
                        e.currentTarget.classList.add('selected');
                        selectedMap = e.currentTarget.dataset.mapId;
                        dom.buttons.nextFromMapSelect.disabled = false;
                    });
                });


                dom.buttons.createGame.addEventListener('click', () => {
                    const gameId = Math.random().toString(36).substring(2, 8).toUpperCase();
                    dom.displays.gameIdDisplay.textContent = gameId;
                    showScreen('waitingRoom');
                });
                
                dom.buttons.startVsAi.addEventListener('click', () => {
                    startArmyAttack();
                });


                dom.buttons.restart.addEventListener('click', () => {
                    audioManager.playMusic('menu');
                    gameState = 'mainMenu';
                    showScreen('mainMenu');
                });

                dom.buttons.specialAbility.addEventListener('click', () => players[0]?.useSpecial());
                dom.buttons.mute.addEventListener('click', () => audioManager.toggleMute());
                dom.buttons.pause.addEventListener('click', togglePause);
                dom.buttons.resume.addEventListener('click', togglePause);
                
                dom.buttons.restartFromPause.addEventListener('click', () => {
                    togglePause();
                    if (gameMode === 'survivor') {
                        startGame(players[0].charType);
                    } else if (gameMode === 'armyAttack') {
                        startArmyAttack();
                    }
                });

                dom.buttons.mainMenuFromPause.addEventListener('click', () => {
                    showScreen('confirmQuit');
                });
                dom.buttons.confirmQuitYes.addEventListener('click', () => {
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                        animationFrameId = null;
                    }
                    showScreen('mainMenu');
                    gameState = 'mainMenu';
                    audioManager.playMusic('menu');
                });
                dom.buttons.confirmQuitNo.addEventListener('click', () => {
                    showScreen('pause');
                });
                dom.buttons.confirmUpgrade.addEventListener('click', () => {
                    selectedUpgrades.forEach(opt => applyUpgrade(opt));
                    selectedUpgrades = [];
                    
                    updateAllUI();
                    setTimeout(() => {
                        showScreen(null);
                        gameState = 'running';
                    }, 300);
                });

                dom.buttons.armyPanelToggle.addEventListener('click', () => {
                    dom.armyPanel.classList.toggle('collapsed');
                });

                dom.buttons.upgradePanelToggle.addEventListener('click', () => {
                    dom.upgradePanel.classList.toggle('collapsed');
                });

                document.querySelectorAll('.army-unit-button').forEach(button => {
                    button.addEventListener('click', () => {
                        const unitType = button.dataset.unit;
                        const cost = armyUnitData[unitType].cost;
                        const humanPlayer = players[0];

                        if (humanPlayer && humanPlayer.wallet >= cost) {
                            humanPlayer.wallet -= cost;
                            audioManager.play('purchase');

                            const spawnX = humanPlayer.x + (Math.random() - 0.5) * 40;
                            const spawnY = humanPlayer.y + (Math.random() - 0.5) * 40;

                            entities.soldiers.push(new Soldier(spawnX, spawnY, humanPlayer, unitType));
                            updateHud();
                            updateFusionUI();
                        } else {
                            console.log("Fonds insuffisants !");
                        }
                    });
                });

                // Écouteurs pour le nouvel écran de fin de partie
                document.getElementById('game-over-lobby-button').addEventListener('click', () => {
                    showScreen('multiplayerLobby'); // Retourne à l'écran du lobby
                    audioManager.playMusic('menu');
                });

                document.getElementById('game-over-quit-button').addEventListener('click', () => {
                    showScreen('mainMenu'); // Retourne au menu principal
                    audioManager.playMusic('menu');
                });

                document.getElementById('game-over-spectate-button').addEventListener('click', () => {
                    showScreen(null); // Cache juste l'écran de défaite pour regarder
                    gameState = 'spectating'; // Un nouvel état pour empêcher la boucle de s'arrêter
                });


                // Gestion des entrées
                window.addEventListener('keydown', (e) => inputManager.handleKey(e.key, true));
                window.addEventListener('keyup', (e) => inputManager.handleKey(e.key, false));
                canvas.addEventListener('touchstart', (e) => inputManager.joystick.start(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => inputManager.joystick.move(e), { passive: false });
                canvas.addEventListener('touchend', (e) => inputManager.joystick.end(e));
                canvas.addEventListener('touchcancel', (e) => inputManager.joystick.end(e));
            }

            function updateZoom() {
                if (window.innerWidth < 768) {
                    zoomFactor = 1.5; // Dézoomer de 50% sur mobile
                } else {
                    zoomFactor = 1.0; // Zoom par défaut sur bureau
                }
            }

            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                updateZoom();
            }

            function togglePause() {
                if (gameState === 'running') {
                    gameState = 'paused';
                    showScreen('pause');
                } else if (gameState === 'paused') {
                    gameState = 'running';
                    lastTime = performance.now(); // Pour éviter un saut de temps
                    showScreen(null);
                }
            }
            
            function startArmyAttack() {
                gameMode = 'armyAttack';
                resetGameState('MVX'); 
                
                showScreen(null); // Hide all menus
                dom.gameHud.classList.remove('hidden'); 
                dom.armyPanel.classList.remove('hidden');
                dom.upgradePanel.classList.remove('hidden');
                setupMultiplayerUpgrades();
                updateFusionUI();
                
                gameState = 'running';
                lastTime = performance.now();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function startGame(charType) {
                gameMode = 'survivor';
                resetGameState(charType);
                audioManager.playMusic('game');

                showScreen(null);
                dom.gameHud.classList.remove('hidden');
                dom.buttons.specialAbility.classList.remove('hidden');
                dom.displays.passiveUpgrades.classList.remove('hidden');
                dom.displays.weaponUI.classList.remove('hidden');
                dom.armyPanel.classList.add('hidden');
                dom.upgradePanel.classList.add('hidden');
                
                updateAllUI();
                
                gameState = 'running';
                lastTime = performance.now();
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function endGame(winner = null) {
                gameState = 'gameOver';
                audioManager.playMusic('gameOver');
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
            
                const humanPlayer = players[0];
                const gameOverTitle = document.getElementById('game-over-title');
                const survivorStats = document.getElementById('survivor-stats');
                const restartButton = document.getElementById('restart-button');
                const lobbyButton = document.getElementById('game-over-lobby-button');
                const spectateButton = document.getElementById('game-over-spectate-button');
                const quitButton = document.getElementById('game-over-quit-button');
                
                // Cache tous les boutons par défaut
                restartButton.classList.add('hidden');
                lobbyButton.classList.add('hidden');
                spectateButton.classList.add('hidden');
                quitButton.classList.add('hidden');
            
                if (gameMode === 'survivor') {
                    globalWallet += humanPlayer.wallet;
                    saveGameState();
                    
                    gameOverTitle.textContent = "LIQUIDATED!";
                    survivorStats.style.display = 'block';
                    document.getElementById('final-time').textContent = formatTime(timers.game);
                    document.getElementById('final-level').textContent = humanPlayer.level;
                    document.getElementById('final-gain').textContent = humanPlayer.wallet;
                    restartButton.classList.remove('hidden');
            
                } else if (gameMode === 'armyAttack') {
                    survivorStats.style.display = 'none'; // On cache les stats de survie
                    
                    if (humanPlayer.hp <= 0) { // Le joueur a perdu
                        gameOverTitle.textContent = "VOUS AVEZ PERDU !";
                        lobbyButton.classList.remove('hidden');
                        quitButton.classList.remove('hidden');
            
                        const alivePlayers = players.filter(p => p.hp > 0).length;
                        if (alivePlayers >= 2) { // S'il reste au moins 2 autres joueurs
                            spectateButton.classList.remove('hidden');
                        }
            
                    } else if (winner && winner.playerId === 1) { // Le joueur a gagné
                        gameOverTitle.textContent = "VICTOIRE !";
                        lobbyButton.classList.remove('hidden');
                        quitButton.classList.remove('hidden');
                    }
                }
                
                dom.gameHud.classList.add('hidden');
                dom.buttons.specialAbility.classList.add('hidden');
                dom.displays.passiveUpgrades.classList.add('hidden');
                dom.displays.weaponUI.classList.add('hidden');
                dom.armyPanel.classList.add('hidden');
                dom.upgradePanel.classList.add('hidden');
                
                showScreen('gameOver');
            }
            
            function resetGameState(charType) {
                players = [];
                const humanPlayer = new Player(charType, 1);
                players.push(humanPlayer);

                if (gameMode === 'survivor') {
                    humanPlayer.x = WORLD_WIDTH / 2;
                    humanPlayer.y = WORLD_HEIGHT / 2;
                    humanPlayer.weapons.push(weaponList.buy.init(humanPlayer));
                } else if (gameMode === 'armyAttack') {
                    // Reset multiplayer upgrades for the new game
                    Object.keys(multiplayerUpgrades).forEach(key => {
                        multiplayerUpgrades[key].level = 0;
                    });

                    if (selectedMap === 'quadrant_4p') {
                        const positions = [
                            { x: WORLD_WIDTH * 0.25, y: WORLD_HEIGHT * 0.25 }, // P1
                            { x: WORLD_WIDTH * 0.75, y: WORLD_HEIGHT * 0.25 }, // P2
                            { x: WORLD_WIDTH * 0.25, y: WORLD_HEIGHT * 0.75 }, // P3
                            { x: WORLD_WIDTH * 0.75, y: WORLD_HEIGHT * 0.75 }  // P4
                        ];
                        
                        players[0].x = positions[0].x;
                        players[0].y = positions[0].y;
                        players[0].weapons.push(weaponList.buy.init(players[0]));

                        const botChars = ['AVAX', 'SOL', 'ETH'];
                        for (let i = 0; i < 3; i++) {
                            const bot = new BotPlayer(botChars[i], i + 2);
                            bot.x = positions[i + 1].x;
                            bot.y = positions[i + 1].y;
                            bot.weapons.push(weaponList.buy.init(bot));
                            players.push(bot);
                        }
                    } else if (selectedMap === 'vertical_2p') {
                          const positions = [
                            { x: WORLD_WIDTH * 0.5, y: WORLD_HEIGHT * 0.25 }, // P1
                            { x: WORLD_WIDTH * 0.5, y: WORLD_HEIGHT * 0.75 }, // P2
                        ];
                        players[0].x = positions[0].x;
                        players[0].y = positions[0].y;
                        players[0].weapons.push(weaponList.buy.init(players[0]));
                        const bot = new BotPlayer('AVAX', 2);
                        bot.x = positions[1].x;
                        bot.y = positions[1].y;
                        bot.weapons.push(weaponList.buy.init(bot));
                        players.push(bot);
                    }
                }
                
                Object.keys(entities).forEach(key => entities[key] = []);
                Object.keys(timers).forEach(key => timers[key] = 0);
                armyAttackTimers = { wave: 0, waveCount: 0 };
                
                activeMiniBoss = null;
                if (gameMode === 'survivor') {
                    spawnBonusUpgrade();
                }
            }

            function gameLoop(timestamp) {
                if (gameState !== 'running' && gameState !== 'spectating') {
                    if (gameState === 'levelUp' || gameState === 'paused') {
                        draw(); // Continue drawing for background effect
                    }
                    animationFrameId = requestAnimationFrame(gameLoop);
                    return;
                };

                const dt = timestamp - lastTime;
                lastTime = timestamp;

                update(dt);
                draw();
                
                animationFrameId = requestAnimationFrame(gameLoop);
            }

            function update(dt) {
                if (gameMode === 'survivor') {
                    updateSurvivor(dt);
                } else if (gameMode === 'armyAttack') {
                    updateArmyAttack(dt);
                }
            }

            function draw() {
                const humanPlayer = players[0];
                if (!humanPlayer && gameState !== 'mainMenu' && gameState !== 'shop') {
                     ctx.clearRect(0, 0, canvas.width, canvas.height);
                     return;
                }

                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Appliquer le zoom et la caméra
                ctx.scale(1 / zoomFactor, 1 / zoomFactor);
                if(humanPlayer) {
                   ctx.translate(-camera.x, -camera.y);
                }

                drawWorldBackground();
                
                if (gameMode === 'armyAttack') {
                    drawArmyAttackElements();
                } 
                
                Object.values(entities).flat().forEach(e => e.draw());
                
                players.forEach(p => {
                    if (p.hp > 0) p.draw();
                });

                ctx.restore();
                
                drawMinimap();
            }

            function updateArmyAttack(dt) {
                timers.game += dt / 1000;
                armyAttackTimers.wave += dt;

                if (armyAttackTimers.wave > TOWER_WAVE_INTERVAL) {
                    spawnArmyWave();
                    armyAttackTimers.wave = 0; 
                }

                players.forEach(p => p.update(dt));
                Object.values(entities).flat().forEach(e => e.update(dt));
                updatePentagrams(dt);

                updateCamera();
                handleCollisions();

                Object.keys(entities).forEach(key => {
                    entities[key] = entities[key].filter(e => e.lifespan === undefined || e.lifespan > 0);
                });
                entities.enemies = entities.enemies.filter(e => e.hp > 0);

                updateHud();
                updateFusionUI(); // Mettre à jour les options de fusion
                updatePentagramUI();

                // Check for winner
                const alivePlayers = players.filter(p => p.hp > 0);
                if (alivePlayers.length <= 1 && gameState === 'running') {
                    endGame(alivePlayers[0]);
                }
            }

            function drawArmyAttackElements() {
                ctx.fillStyle = 'rgb(17, 34, 64)';
                if (selectedMap === 'quadrant_4p') {
                    ctx.fillRect(WORLD_WIDTH / 2 - 10, 0, 20, WORLD_HEIGHT);
                    ctx.fillRect(0, WORLD_HEIGHT / 2 - 10, WORLD_WIDTH, 20);
                } else if (selectedMap === 'vertical_2p') {
                    ctx.fillRect(0, WORLD_HEIGHT / 2 - 10, WORLD_WIDTH, 20);
                }
            }

            function updateSurvivor(dt) {
                const humanPlayer = players[0];
                timers.game += dt / 1000;
                timers.enemySpawn += dt;
                timers.magnetSpawn += dt;
                timers.healthSpawn += dt;
                
                if (timers.enemySpawn > ENEMY_BASE_SPAWN_RATE) {
                    spawnEnemyWave();
                    timers.enemySpawn = 0;
                }
                if (timers.magnetSpawn > MAGNET_SPAWN_RATE) {
                    entities.magnets.push(new Magnet(camera.x + Math.random() * canvas.width, camera.y + Math.random() * canvas.height));
                    timers.magnetSpawn = 0;
                }
                if (timers.healthSpawn > HEALTH_SPAWN_RATE) {
                    entities.healthPickups.push(new HealthPickup(camera.x + Math.random() * canvas.width, camera.y + Math.random() * canvas.height));
                    timers.healthSpawn = 0;
                }

                humanPlayer.update(dt);
                updateCamera();
                Object.values(entities).flat().forEach(e => e.update(dt));

                handleCollisions();
                
                Object.keys(entities).forEach(key => {
                    entities[key] = entities[key].filter(e => e.lifespan === undefined || e.lifespan > 0);
                });
                entities.enemies = entities.enemies.filter(e => e.hp > 0);

                updateHud();
            }

            function updateCamera() {
                const humanPlayer = players[0];
                if (!humanPlayer) return;

                const viewWidth = canvas.width * zoomFactor;
                const viewHeight = canvas.height * zoomFactor;

                camera.x = humanPlayer.x - viewWidth / 2;
                camera.y = humanPlayer.y - viewHeight / 2;
                
                const bounds = getQuadrantBoundaries(humanPlayer.playerId);
                camera.x = Math.max(bounds.minX, Math.min(bounds.maxX - viewWidth, camera.x));
                camera.y = Math.max(bounds.minY, Math.min(bounds.maxY - viewHeight, camera.y));
            }

            function drawMinimap() {
                if (players.length === 0) return;

                const minimap = dom.displays.minimapCanvas;
                const minimapCtx = minimap.getContext('2d');
                const mapWidth = minimap.width;
                const mapHeight = minimap.height;

                minimapCtx.fillStyle = 'rgba(17, 34, 64, 0.8)';
                minimapCtx.fillRect(0, 0, mapWidth, mapHeight);

                minimapCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
                minimapCtx.lineWidth = 1;
                minimapCtx.beginPath();
</body>
</html>
